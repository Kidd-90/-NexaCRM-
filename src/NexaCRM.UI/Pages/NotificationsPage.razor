@page "/notifications"
@using System.Text.Json
@using Microsoft.Extensions.Logging
@inject IJSRuntime JS
@inject INotificationFeedService Feed
@inject ILogger<NotificationsPage> Logger

<div class="notifications-page">
    <div class="notifications-header">
        <h1>ì•Œë¦¼</h1>
        <div class="actions">
            @if (!isLoading)
            {
                <button class="refresh-button" @onclick="RefreshAsync" title="ìƒˆë¡œê³ ì¹¨">
                    <span>ğŸ”„</span>
                </button>
                <button class="mark-read" @onclick="MarkAllRead" disabled="@(items.Count == 0 || items.All(x => x.IsRead))">
                    ëª¨ë‘ ì½ìŒ ì²˜ë¦¬
                </button>
            }
            <a class="settings-link" href="/notification-settings-page">ì•Œë¦¼ ì„¤ì •</a>
        </div>
    </div>

    @if (isLoading)
    {
        <div class="loading-state">
            <span class="spinner"></span>
            <span>ì•Œë¦¼ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...</span>
        </div>
    }
    else if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="error-state">
            <strong>ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤</strong>
            <p>@errorMessage</p>
            <button class="retry-button" @onclick="RefreshAsync">ë‹¤ì‹œ ì‹œë„</button>
        </div>
    }
    else if (items.Count == 0)
    {
        <div class="empty-state">
            <span class="empty-icon">ğŸ””</span>
            <p>í‘œì‹œí•  ì•Œë¦¼ì´ ì—†ìŠµë‹ˆë‹¤.</p>
            <p class="empty-hint">ë¡œê·¸ì¸ì´ ë˜ì–´ ìˆì§€ ì•Šê±°ë‚˜ ìƒˆë¡œìš´ ì•Œë¦¼ì´ ì—†ìŠµë‹ˆë‹¤.</p>
        </div>
    }
    else
    {
        <div class="notifications-stats">
            <span class="total-count">ì „ì²´ @(items.Count)ê°œ</span>
            <span class="unread-count">ì½ì§€ ì•ŠìŒ @(items.Count(x => !x.IsRead))ê°œ</span>
        </div>
        
        <ul class="notif-list">
            @for (var i = 0; i < items.Count; i++)
            {
                var n = items[i];
                var anim = justReadIndices.Contains(i) ? "mark-read-anim" : null;
                <li class="notif-item @(n.IsRead ?"read" : "unread") @anim">
                    <div class="icon type-@n.Type.ToString().ToLower()"></div>
                    <div class="body">
                        <div class="title">@n.Title</div>
                        <div class="message">@n.Message</div>
                        <div class="meta">@n.TimeLocal.ToString("yyyy.MM.dd HH:mm")</div>
                    </div>
                </li>
            }
        </ul>
    }
</div>

@code {
    private List<NotificationItem> items = new();
    private HashSet<int> justReadIndices = new();
    private bool isLoading = true;
    private string? errorMessage;

    protected override async Task OnInitializedAsync()
    {
        await LoadAsync();
    }

    private async Task LoadAsync()
    {
        try
        {
            isLoading = true;
            errorMessage = null;
            Logger.LogInformation("[NotificationsPage] Loading notifications...");
            
            var list = await Feed.GetAsync();
            Logger.LogInformation("[NotificationsPage] Feed.GetAsync returned {Count} items.", list.Count);
            
            items = list.Select(x => new NotificationItem(
                x.Title, 
                x.Message, 
                x.TimestampUtc, 
                x.IsRead, 
                ToType(x.Type)
            )).ToList();
            
            Logger.LogInformation("[NotificationsPage] Successfully loaded {Count} notifications.", items.Count);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NotificationsPage] Failed to load notifications. Error: {Message}", ex.Message);
            
            var detailedError = $"ì•Œë¦¼ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: {ex.Message}";
            if (ex.InnerException != null)
            {
                detailedError += $" (ë‚´ë¶€ ì˜¤ë¥˜: {ex.InnerException.Message})";
                Logger.LogError("[NotificationsPage] Inner exception: {InnerMessage}", ex.InnerException.Message);
            }
            
            errorMessage = detailedError;
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task RefreshAsync()
    {
        await LoadAsync();
    }

    private async Task MarkAllRead()
    {
        // Capture indices of items that were unread, then mark as read locally for instant UI feedback
        var toAnimate = items
            .Select((n, idx) => new { n, idx })
            .Where(x => !x.n.IsRead)
            .Select(x => x.idx)
            .ToList();

        foreach (var idx in toAnimate)
        {
            items[idx].IsRead = true;
        }

        justReadIndices = new HashSet<int>(toAnimate);
        StateHasChanged();

        // Persist read state to the feed service
        await Feed.MarkAllReadAsync();

        // Optionally clear the animation flag after a short delay
        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(1200);
                justReadIndices.Clear();
                await InvokeAsync(StateHasChanged);
            }
            catch { }
        });
    }

    private static NotificationType ToType(string type) => type?.ToLowerInvariant() switch
    {
        "success" => NotificationType.Success,
        "warning" => NotificationType.Warning,
        "error" => NotificationType.Error,
        _ => NotificationType.Info
    };

    private class NotificationItem
    {
        public string Title { get; set; } = string.Empty;
        public string Message { get; set; } = string.Empty;
        public DateTime TimeUtc { get; set; } = DateTime.UtcNow;
        public bool IsRead { get; set; }
        public NotificationType Type { get; set; } = NotificationType.Info;

        public NotificationItem() {}

        public NotificationItem(string title, string message, DateTime timeUtc, bool isRead, NotificationType type)
        {
            Title = title; Message = message; TimeUtc = timeUtc; IsRead = isRead; Type = type;
        }

        public DateTime TimeLocal => TimeUtc.ToLocalTime();
    }

    private enum NotificationType { Info, Success, Warning, Error }
}
