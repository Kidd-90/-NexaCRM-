@page "/notifications"
@using System.Text.Json
@using Microsoft.Extensions.Logging
@inject IJSRuntime JS
@inject INotificationFeedService Feed
@inject ILogger<NotificationsPage> Logger

<div class="notifications-page">
    <div class="notifications-header">
        <h1>알림</h1>
        <div class="actions">
            @if (!isLoading)
            {
                <button class="refresh-button" @onclick="RefreshAsync" title="새로고침">
                    <span>🔄</span>
                </button>
                <button class="mark-read" @onclick="MarkAllRead" disabled="@(items.Count == 0 || items.All(x => x.IsRead))">
                    모두 읽음 처리
                </button>
            }
            <a class="settings-link" href="/notification-settings-page">알림 설정</a>
        </div>
    </div>

    @if (isLoading)
    {
        <div class="loading-state">
            <span class="spinner"></span>
            <span>알림을 불러오는 중입니다...</span>
        </div>
    }
    else if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="error-state">
            <strong>오류가 발생했습니다</strong>
            <p>@errorMessage</p>
            <button class="retry-button" @onclick="RefreshAsync">다시 시도</button>
        </div>
    }
    else if (items.Count == 0)
    {
        <div class="empty-state">
            <span class="empty-icon">🔔</span>
            <p>표시할 알림이 없습니다.</p>
            <p class="empty-hint">로그인이 되어 있지 않거나 새로운 알림이 없습니다.</p>
        </div>
    }
    else
    {
        <div class="notifications-stats">
            <span class="total-count">전체 @(items.Count)개</span>
            <span class="unread-count">읽지 않음 @(items.Count(x => !x.IsRead))개</span>
        </div>
        
        <ul class="notif-list">
            @for (var i = 0; i < items.Count; i++)
            {
                var n = items[i];
                var anim = justReadIndices.Contains(i) ? "mark-read-anim" : null;
                <li class="notif-item @(n.IsRead ?"read" : "unread") @anim">
                    <div class="icon type-@n.Type.ToString().ToLower()"></div>
                    <div class="body">
                        <div class="title">@n.Title</div>
                        <div class="message">@n.Message</div>
                        <div class="meta">@n.TimeLocal.ToString("yyyy.MM.dd HH:mm")</div>
                    </div>
                </li>
            }
        </ul>
    }
</div>

@code {
    private List<NotificationItem> items = new();
    private HashSet<int> justReadIndices = new();
    private bool isLoading = true;
    private string? errorMessage;

    protected override async Task OnInitializedAsync()
    {
        await LoadAsync();
    }

    private async Task LoadAsync()
    {
        try
        {
            isLoading = true;
            errorMessage = null;
            Logger.LogInformation("[NotificationsPage] Loading notifications...");
            
            var list = await Feed.GetAsync();
            Logger.LogInformation("[NotificationsPage] Feed.GetAsync returned {Count} items.", list.Count);
            
            items = list.Select(x => new NotificationItem(
                x.Title, 
                x.Message, 
                x.TimestampUtc, 
                x.IsRead, 
                ToType(x.Type)
            )).ToList();
            
            Logger.LogInformation("[NotificationsPage] Successfully loaded {Count} notifications.", items.Count);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NotificationsPage] Failed to load notifications. Error: {Message}", ex.Message);
            
            var detailedError = $"알림을 불러오지 못했습니다: {ex.Message}";
            if (ex.InnerException != null)
            {
                detailedError += $" (내부 오류: {ex.InnerException.Message})";
                Logger.LogError("[NotificationsPage] Inner exception: {InnerMessage}", ex.InnerException.Message);
            }
            
            errorMessage = detailedError;
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task RefreshAsync()
    {
        await LoadAsync();
    }

    private async Task MarkAllRead()
    {
        // Capture indices of items that were unread, then mark as read locally for instant UI feedback
        var toAnimate = items
            .Select((n, idx) => new { n, idx })
            .Where(x => !x.n.IsRead)
            .Select(x => x.idx)
            .ToList();

        foreach (var idx in toAnimate)
        {
            items[idx].IsRead = true;
        }

        justReadIndices = new HashSet<int>(toAnimate);
        StateHasChanged();

        // Persist read state to the feed service
        await Feed.MarkAllReadAsync();

        // Optionally clear the animation flag after a short delay
        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(1200);
                justReadIndices.Clear();
                await InvokeAsync(StateHasChanged);
            }
            catch { }
        });
    }

    private static NotificationType ToType(string type) => type?.ToLowerInvariant() switch
    {
        "success" => NotificationType.Success,
        "warning" => NotificationType.Warning,
        "error" => NotificationType.Error,
        _ => NotificationType.Info
    };

    private class NotificationItem
    {
        public string Title { get; set; } = string.Empty;
        public string Message { get; set; } = string.Empty;
        public DateTime TimeUtc { get; set; } = DateTime.UtcNow;
        public bool IsRead { get; set; }
        public NotificationType Type { get; set; } = NotificationType.Info;

        public NotificationItem() {}

        public NotificationItem(string title, string message, DateTime timeUtc, bool isRead, NotificationType type)
        {
            Title = title; Message = message; TimeUtc = timeUtc; IsRead = isRead; Type = type;
        }

        public DateTime TimeLocal => TimeUtc.ToLocalTime();
    }

    private enum NotificationType { Info, Success, Warning, Error }
}
