@page "/login"
@layout LoginLayout
@attribute [AllowAnonymous]
@using System.Linq
@using Microsoft.Extensions.Localization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.JSInterop
@implements IDisposable
@inject IStringLocalizer<LoginPage> Localizer
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IAuthenticationService AuthenticationService
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject ILogger<LoginPage> Logger

<div class="login-container mobile-login-container white-theme white-theme-gradient-light">
  <!-- íƒœë¸”ë¦¿/ë°ìŠ¤í¬í†±ìš© ì´ë¯¸ì§€ ì˜ì—­ -->
  <div class="login-image-section">
    <div class="login-image-backdrop image-wrap">
  <div class="image-layer layer-a @(frontIsA ? "visible" : "")" @ref="layerARef" style="background-image: @(layerABackground)"></div>
  <div class="image-layer layer-b @(!frontIsA ? "visible" : "")" @ref="layerBRef" style="background-image: @(layerBBackground)"></div>
    </div>
    <div class="login-image-content">
      <h1 class="login-image-title">Welcome to Nexa DB</h1>
      <p class="login-image-subtitle">Your powerful CRM solution</p>
    </div>
    
    <!-- ì´ë¯¸ì§€ ì„ íƒ ì¸ë””ì¼€ì´í„° -->
    <div class="image-indicators" role="tablist" aria-label="ì´ë¯¸ì§€ ì„ íƒ">
      @for (int i = 0; i < imageUrls.Length; i++)
      {
        var index = i;
        <button type="button" class="indicator-dot @(currentImageIndex == index ?"active" : "")" 
                @onclick="() => SetImage(index)"
                aria-label="@($"ì´ë¯¸ì§€ {index + 1}")"
                aria-current="@(currentImageIndex == index ? "true" : null)">
        </button>
      }
    </div>
  </div>
  
  <div class="mobile-login-card">
    <div class="brand-section">
      <span class="brand-logo">Nexa DB</span>
      <p class="brand-caption">@Localizer["SignInToYourAccount"]</p>
    </div>

    <div class="mobile-form">
      <div class="input-group">
        <label class="input-label" for="login-username">@Localizer["Username"]</label>
        <input
          id="login-username"
          @bind="username"
          placeholder="@Localizer["EnterYourUsername"]"
          autocomplete="username"
          class="login-input"
        />
      </div>

      <div class="input-group">
        <label class="input-label" for="login-password">@Localizer["Password"]</label>
        <div class="password-wrapper">
          <input
            id="login-password"
            @bind="password"
            type="@PasswordInputType"
            placeholder="@Localizer["EnterYourPassword"]"
            autocomplete="current-password"
            class="login-input"
          />
          <button type="button" class="password-toggle" @onclick="TogglePasswordVisibility">
            @PasswordToggleText
          </button>
        </div>
      </div>

      <label class="remember-me" for="remember-me-checkbox">
        <input id="remember-me-checkbox" type="checkbox" class="remember-checkbox" @bind="rememberMe" aria-label="ë¡œê·¸ì¸ ID ì €ì¥" />
        <span>ë¡œê·¸ì¸ ID ì €ì¥</span>
      </label>
    </div>

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="login-error-message" role="alert">
            <span>@errorMessage</span>
        </div>
    }

    <button @onclick="Login" type="button" disabled="@isLoading" class="login-button">
      @if (isLoading)
      {
        <div class="button-loading">
          <div class="loading-spinner">
            <svg class="animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
              <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
          </div>
          <span>@Localizer["LoggingIn"]</span>
        </div>
      }
      else
      {
        <span>@Localizer["LogIn"]</span>
      }
    </button>

    <div class="login-helper-links">
      <a href="/find-id-page" class="login-link">@Localizer["FindId"]</a>
      <span class="divider-dot" aria-hidden="true"></span>
      <a href="/password-reset-page" class="login-link">@Localizer["ResetPassword"]</a>
      <span class="divider-dot" aria-hidden="true"></span>
      <a href="/user-registration-page" class="login-link">@Localizer["SignUp"]</a>
    </div>

    <div class="login-divider">
      <span>@Localizer["OrLogInWith"]</span>
    </div>

    <div class="social-login-grid">
      <button class="social-login-btn naver-btn" type="button" disabled aria-disabled="true" title="@Localizer["SocialLoginComingSoon"]">
        <span class="social-icon">
          <svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
            <rect width="32" height="32" rx="16" fill="#03C75A" />
            <!-- Center the N logo horizontally within the 32x32 rect -->
            <path d="M19.8 10h-3.64v5.5L12.2 10H9v12h3.6v-5.5l3.96 5.5h3.24V10z" fill="#ffffff" transform="translate(1.6,0)" />
          </svg>
        </span>
        <span class="social-text">@Localizer["Naver"]</span>
      </button>

      <button class="social-login-btn google-btn" type="button" disabled aria-disabled="true" title="@Localizer["SocialLoginComingSoon"]">
        <span class="social-icon">
          <svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
            <path fill="#4285F4" d="M28.16 16.26c0-.94-.08-1.8-.24-2.6H16v4.92h6.84c-.3 1.62-1.2 2.98-2.56 3.88v3.3h4.14c2.4-2.2 3.74-5.44 3.74-9.5z"/>
            <path fill="#34A853" d="M16 29.3c3.46 0 6.34-1.14 8.46-3.1l-4.14-3.3c-1.14.76-2.6 1.2-4.32 1.2-3.33 0-6.16-2.24-7.16-5.26H4.46v3.33C6.56 26.68 10.9 29.3 16 29.3z"/>
            <path fill="#FBBC05" d="M8.84 18.84c-.26-.78-.4-1.62-.4-2.48s.14-1.7.4-2.48V10.6H4.46A12.98 12.98 0 003 16.36c0 2.06.5 4 1.46 5.76l4.38-3.28.97-.7z"/>
            <path fill="#EA4335" d="M16 9.14c1.9 0 3.62.66 4.98 1.96l3.73-3.72C22.32 4.7 19.44 3.4 16 3.4 10.9 3.4 6.56 6.02 4.46 10.6l4.38 3.28c1-3.02 3.83-5.26 7.16-5.26z"/>
          </svg>
        </span>
        <span class="social-text">@Localizer["Google"]</span>
      </button>

      <button class="social-login-btn kakao-btn" type="button" disabled aria-disabled="true" title="@Localizer["SocialLoginComingSoon"]">
        <span class="social-icon">
          <svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
            <rect width="32" height="32" rx="16" fill="#FEE500" />
            <path d="M16 8c-4.7 0-8.5 2.76-8.5 6.16 0 2.34 1.76 4.36 4.32 5.42-.16.6-.58 2.1-.66 2.42-.1.4.14.78.56.66.58-.16 2.16-1.4 3.02-2.08.4.04.82.06 1.24.06 4.7 0 8.5-2.76 8.5-6.16C24.5 10.76 20.7 8 16 8z" fill="#381E1F" />
          </svg>
        </span>
        <span class="social-text">@Localizer["Kakao"]</span>
      </button>
    </div>
    <p class="social-login-notice">@Localizer["SocialLoginComingSoon"]</p>
  </div>
</div>

@code {
    private string username = string.Empty;
    private string password = string.Empty;
    private string? errorMessage;
    private bool isLoading = false;
    private bool isPasswordVisible = false;
  // remember-me support: when true, store the username in localStorage
  private bool rememberMe = false;
  private const string RememberUsernameKey = "nexacrm.rememberedUsername";

    private string PasswordInputType => isPasswordVisible ? "text" : "password";

    private string PasswordToggleText => isPasswordVisible
        ? Localizer["HidePassword"]
        : Localizer["ShowPassword"];

  protected override async Task OnInitializedAsync()
  {
    await CheckExistingAuthentication();
    // load previously-remembered username (if any)
    await LoadRememberedUsernameAsync();
  }

    private async Task CheckExistingAuthentication()
    {
        try
        {
            // ì´ë¯¸ ì¸ì¦ëœ ì‚¬ìš©ìì¸ì§€ í™•ì¸
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var user = authState.User;

            if (user.Identity?.IsAuthenticated == true)
            {
                await JSRuntime.InvokeVoidAsync("console.log", "User already authenticated, redirecting from login page");

                // ì‚¬ìš©ì ì—­í• ì— ë”°ë¼ ì ì ˆí•œ ëŒ€ì‹œë³´ë“œë¡œ ë¦¬ë‹¤ì´ë ‰ì…˜
                if (user.IsInRole("Manager"))
                {
                    NavigationManager.NavigateTo("/manager-dashboard");
                }
                else if (user.IsInRole("Sales"))
                {
                    NavigationManager.NavigateTo("/sales-dashboard");
                }
                else
                {
                    NavigationManager.NavigateTo("/admin-dashboard");
                }
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", $"Error checking authentication: {ex.Message}");
        }
    }

    private async Task Login()
    {
        Logger.LogInformation("Login invoked for user {User}", string.IsNullOrWhiteSpace(username) ? "<empty>" : username);

        errorMessage = null;
        isLoading = true;
        // Ensure the UI updates (spinner + text) before doing the sign-in work.
        // Use InvokeAsync(StateHasChanged) so the renderer has a chance to flush
        // the updated markup to the client/browser.
        await InvokeAsync(StateHasChanged);

    try
    {
      try
      {
        await JSRuntime.InvokeVoidAsync(identifier: "console.log", "Attempting Supabase login");
      }
      catch (JSException) { /* JSInterop ì‹¤íŒ¨ ë¬´ì‹œ */ }

      // Small delay to ensure spinner renders on the client and any
      // CSS animations start before we run the sign-in logic.
      try { await Task.Delay(120); } catch { }
      try { await JSRuntime.InvokeVoidAsync("console.log", "Calling AuthenticationService.SignInAsync"); } catch {}

      // Run the sign-in on the thread-pool to avoid accidentally blocking the
      // Blazor renderer / synchronization context if the implementation does
      // synchronous work internally. AuthenticationService.SignInAsync is
      // expected to be async; wrapping it in Task.Run is a defensive measure.
      var result = await Task.Run(async () => await AuthenticationService.SignInAsync(username, password));
      if (!result.Succeeded)
            {
                errorMessage = result.ErrorMessage ?? "ë¡œê·¸ì¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.";
                try
                {
                    await JSRuntime.InvokeVoidAsync("console.warn", $"Login failed for {username} with reason {result.FailureReason}.");
                }
                catch (JSException) { /* JSInterop ì‹¤íŒ¨ ë¬´ì‹œ */ }
                return;
            }

      // Persist or remove the remembered username based on the checkbox.
      try
      {
        if (rememberMe && !string.IsNullOrWhiteSpace(username))
        {
          await JSRuntime.InvokeVoidAsync("localStorage.setItem", RememberUsernameKey, username);
        }
        else
        {
          await JSRuntime.InvokeVoidAsync("localStorage.removeItem", RememberUsernameKey);
        }
      }
      catch (JSException) { /* ignore JSInterop errors for localStorage */ }

            // ì¸ì¦ ìƒíƒœê°€ ì—…ë°ì´íŠ¸ë  ì‹œê°„ì„ ì£¼ê¸° ìœ„í•´ ì§€ì—°
            //await Task.Delay(200);

            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var user = authState.User;

            var isAuthenticated = user.Identity?.IsAuthenticated ?? false;
            var roles = string.Join(",", user.Claims.Where(c => c.Type == System.Security.Claims.ClaimTypes.Role).Select(c => c.Value));
            
            Logger.LogInformation("ğŸ” Login complete - IsAuthenticated={IsAuth}, Roles={Roles}", isAuthenticated, roles);
            
            try
            {
                await JSRuntime.InvokeVoidAsync("console.log", $"Auth state after login: IsAuthenticated={isAuthenticated}, Roles={roles}");
            }
            catch (JSException) { /* JSInterop ì‹¤íŒ¨ ë¬´ì‹œ */ }

            if (!isAuthenticated)
            {
                Logger.LogWarning("âš ï¸ User not authenticated after login, staying on login page");
                errorMessage = "ì¸ì¦ ìƒíƒœ í™•ì¸ ì‹¤íŒ¨. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.";
                return;
            }

            // ê°™ì€ Circuitì—ì„œ ë„¤ë¹„ê²Œì´ì…˜ (forceLoad ì œê±°í•˜ì—¬ ì„¸ì…˜ ìœ ì§€)
            string targetUrl;
            if (user.IsInRole("Manager"))
            {
                targetUrl = "/sales-manager-dashboard";
            }
            else if (user.IsInRole("Sales"))
            {
                targetUrl = "/sales-dashboard";
            }
            else
            {
                targetUrl = "/admin-dashboard";
            }
            
            Logger.LogInformation("ğŸš€ Navigating to {Url}", targetUrl);
            NavigationManager.NavigateTo(targetUrl);
        }
        catch (JSException jsEx)
        {
            Logger.LogWarning("JSInterop error during login (safe to ignore): {Message}", jsEx.Message);
            // JSInterop ì˜¤ë¥˜ëŠ” ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error during login for user {User}", username);
            errorMessage = "ë¡œê·¸ì¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.";
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private void TogglePasswordVisibility()
    {
        isPasswordVisible = !isPasswordVisible;
    }

  private async Task LoadRememberedUsernameAsync()
  {
    try
    {
      var saved = await JSRuntime.InvokeAsync<string>("localStorage.getItem", RememberUsernameKey);
      if (!string.IsNullOrEmpty(saved))
      {
        username = saved;
        rememberMe = true;
        await InvokeAsync(StateHasChanged);
      }
    }
    catch (JSException) { /* ignore */ }
    catch { /* ignore other errors */ }
  }

  // ì´ë¯¸ì§€ ìŠ¬ë¼ì´ë“œì‡¼ (ë”ë¸”ë²„í¼ ì „í™˜)
  private string[] imageUrls = new[]
    {
        "/_content/NexaCRM.UI/images/split1.jpg",
        "/_content/NexaCRM.UI/images/split2.jpg",
        "/_content/NexaCRM.UI/images/split3.jpg"
    };
    
    private int currentImageIndex = 0;
  private System.Threading.Timer? imageTimer;

  // double-buffer helpers
  private ElementReference layerARef;
  private ElementReference layerBRef;
  private bool frontIsA = true;
  private string layerABackground = string.Empty;
  private string layerBBackground = string.Empty;

    protected override void OnInitialized()
    {
        base.OnInitialized();
    // initialize front layer background
    layerABackground = $"url('{imageUrls[0]}')";
    StartImageSlideshow();
    }

    private void StartImageSlideshow()
    {
        imageTimer = new System.Threading.Timer(_ =>
        {
      var next = (currentImageIndex + 1) % imageUrls.Length;
      // call async SetImage via the renderer
      InvokeAsync(() => SetImage(next));
        }, null, TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(10));
    }

  private async Task SetImage(int index)
  {
    // bounds
    if (index < 0 || index >= imageUrls.Length) return;

    var url = imageUrls[index];

    try
    {
      // Preload & decode via small JS helper to avoid flicker
      await JSRuntime.InvokeVoidAsync("loginImages.preload", url);
    }
    catch
    {
      // ignore preload errors and continue to set image
    }

    // set on back layer then crossfade
    if (frontIsA)
    {
      layerBBackground = $"url('{url}')";
      currentImageIndex = index;
      frontIsA = false;
    }
    else
    {
      layerABackground = $"url('{url}')";
      currentImageIndex = index;
      frontIsA = true;
    }

    // restart timer
    imageTimer?.Dispose();
    StartImageSlideshow();

    await InvokeAsync(StateHasChanged);
  }

    private string GetCurrentImageUrl()
    {
        return imageUrls[currentImageIndex];
    }

    public void Dispose()
    {
        imageTimer?.Dispose();
    }
}

<script>
  // Small helper to preload an image and decode it to avoid flicker.
  window.loginImages = window.loginImages || {};
  window.loginImages.preload = function (url) {
    return new Promise(function (resolve, reject) {
      try {
        const img = new Image();
        img.onload = function () { resolve(true); };
        img.onerror = function () { resolve(false); };
        // use decode if available for extra safety
        img.src = url;
        if (img.decode) {
          img.decode().then(function () { resolve(true); }).catch(function () { resolve(false); });
        }
      } catch (e) {
        resolve(false);
      }
    });
  };
</script>
