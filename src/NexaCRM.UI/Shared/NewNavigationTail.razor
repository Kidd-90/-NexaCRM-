@using System.Linq
@using System.Security.Claims
@using System.Text.Json
@using System.Text.Json.Serialization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Routing
@using NexaCRM.UI.Services.Interfaces
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject Microsoft.Extensions.Logging.ILogger<NewNavigationTail> Logger
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IRolePermissionService RolePermissionService
@inject IAuthenticationService AuthenticationService
@inject Microsoft.Extensions.Localization.IStringLocalizer<NavMenu> Localizer
@using NexaCRM.UI.Models.Navigation

<div class='@BuildSidebarClasses()' role="navigation" data-viewport='@GetViewportCategoryKey(_currentViewportCategory)'>
    <div class="sidebar-rail">
        <a href="/" class="rail-logo" title="Online store">
            <img src="https://localhost:7065/_content/NexaCRM.UI/images/logo.svg" alt="Logo" class="rail-logo-img" />
        </a>

        <ul class="rail-list">
            @for (var i = 0; i < visibleGroups.Count; i++)
            {
                var g = visibleGroups[i];
                var tooltip = g.DisplayName;
                        <li>
                    <button role="tab" class="rail-btn @(activeSubMenuIndex == i ? "active" : "")"
                            title="@tooltip"
                            aria-label="@tooltip"
                            aria-selected="@(activeSubMenuIndex == i ? "true" : "false")"
                            tabindex="0"
                            @onclick="async () => await ToggleSubMenuByKey(g.Key)"
                            @onkeydown="async (e) => await HandleKeyDown(e, g.Key)">
                        @RenderIcon(g.IconCss, "rail-icon")
                    </button>
                </li>
            }
        </ul>

        <div class="rail-footer">
            <button class="rail-avatar" title="Profile">
                <img src="https://localhost:7065/_content/NexaCRM.UI/images/avatar.png" alt="avatar" />
            </button>
        </div>
    </div>

    <div class="sidebar-panel @(ShouldShowPanel ? "open" : string.Empty)">
        <div class="panel-header">
            <div class="panel-header-text">
                <div class="panel-title">Online store</div>
                <div class="panel-subtitle">Untitled UI</div>
            </div>
            <div class="panel-header-actions">
                <button type="button" class="panel-action panel-dismiss" @onclick="ClosePanelFromHeader" title="Close navigation" aria-label="Close navigation panel">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
        </div>

        <div class="panel-body">
            @{ var hasValidIndex = activeSubMenuIndex.HasValue && activeSubMenuIndex.Value >= 0 && activeSubMenuIndex.Value < visibleGroups.Count; }
            @if (!hasValidIndex)
            {
                <div class="panel-empty">Select a menu item</div>
            }
            else
            {
                var grp = visibleGroups[activeSubMenuIndex.Value];
                var grouped = GroupLinks(grp.Links);
                @foreach (var sub in grouped)
                {
                        var hasActiveInSub = sub.Links.Any(l => string.Equals(NormalizePath(l.Href), selectedItem, StringComparison.OrdinalIgnoreCase));
                        <div class="panel-subgroup @(hasActiveInSub ? "subgroup-has-active" : "")">
                            <div class="panel-subgroup-title">
                                @{
                                    // Choose an icon for the subgroup title. Prefer a mapping based on
                                    // the friendly title; fall back to the first link's IconCss if present.
                                    var friendly = ToFriendlyGroupTitle(sub.Title);
                                    var firstIcon = sub.Links.FirstOrDefault()?.IconCss;
                                    var titleIconKey = MapIcon(friendly, firstIcon ?? string.Empty);
                                    // Determine expansion state: keep expanded if it contains an active
                                    // link, or the user explicitly expanded it.
                                    var isExpanded = hasActiveInSub || openSubgroups.Contains(sub.Title);
                                }
                                @RenderIcon(titleIconKey, "group-title-icon")
                                <span class="group-title-text">@friendly</span>

                                <button class="subgroup-toggler" aria-expanded="@isExpanded" @onclick="() => ToggleSubgroup(sub.Title)" title="Toggle details">
                                    @((MarkupString)(isExpanded ? "&minus;" : "+"))
                                </button>
                            </div>
                            <ul class="panel-list @(isExpanded ? "" : "collapsed")">
                                @foreach (var link in sub.Links)
                                {
                                    var isActive = string.Equals(NormalizePath(link.Href), selectedItem, StringComparison.OrdinalIgnoreCase);
                                    <li class='@(isActive ? "item-active" : "")'>
                                        <a href="@link.Href" class='@(isActive ? "active page-active" : "")' @onclick='() => SelectItem(link.Href)'>
                                            <span class="link-text">@link.DisplayName</span>
                                        </a>
                                    </li>
                                }
                            </ul>
                        </div>
                }
            }
        </div>

        <div class="panel-footer">
                <div class="profile-card">
                <img src="https://localhost:7065/_content/NexaCRM.UI/images/avatar.png" alt="User Avatar" />
                <div class="profile-info">
                    <div class="profile-name">Sophia Munn</div>
                    <div class="profile-email">sophia@untitledui.com</div>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    private bool isRailCollapsed;
    private int? activeSubMenuIndex;
    private string? selectedItem = null;
    private DotNetObjectReference<NewNavigationTail>? _dotNetRef;
    private IJSObjectReference? _viewportModule;
    private bool _overlayPanelHidden = true;
    private bool _storageHydrated;
    private ViewportCategory _currentViewportCategory = ViewportCategory.Desktop;
    private NavigationStorageSnapshot _storageSnapshot = CreateEmptySnapshot();

    private readonly List<NavGroupVm> visibleGroups = new();
    // Track which subgroups are expanded in the panel. Keys are the subgroup.Title values
    // produced by GroupLinks (eg. first path segment or db/... keys).
    private readonly HashSet<string> openSubgroups = new(StringComparer.OrdinalIgnoreCase);

    private const string StorageKey = "nexacrm.activeSubMenuState.v2";
    private static readonly JsonSerializerOptions StorageSerializerOptions = new(JsonSerializerDefaults.Web)
    {
        PropertyNameCaseInsensitive = true,
        WriteIndented = false,
        DefaultIgnoreCondition = JsonIgnoreCondition.Never
    };

    private bool ShouldShowPanel => activeSubMenuIndex.HasValue && (!PanelShouldOverlay || !_overlayPanelHidden);
    private bool PanelShouldOverlay => _currentViewportCategory is ViewportCategory.Mobile or ViewportCategory.Tablet;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        _dotNetRef ??= DotNetObjectReference.Create(this);
        await LoadGroupsAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        if (!firstRender)
        {
            return;
        }

        _dotNetRef ??= DotNetObjectReference.Create(this);

        var category = await InitializeViewportCategoryAsync();
        await HydrateStorageCacheAsync();
        await ApplyViewportCategoryAsync(category, isInitial: true);
        await RegisterStorageSyncAsync();
    }

    private async Task RegisterStorageSyncAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("navigationStorageSync.registerDotNet", _dotNetRef, StorageKey);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to register navigationStorageSync: {ex}");
            try { Logger?.LogDebug(ex, "navigationStorageSync registration failed"); } catch { }
        }

        // attempt to restore previously selected group from localStorage for the current viewport
        try
        {
            var stored = await LoadActiveIndexFromStorageAsync();
            if (stored.HasValue && stored.Value >= 0 && stored.Value < visibleGroups.Count)
            {
                activeSubMenuIndex = stored.Value;
                if (PanelShouldOverlay)
                {
                    _overlayPanelHidden = false;
                }
            }
        }
        catch { }
    }

    private async Task<ViewportCategory> InitializeViewportCategoryAsync()
    {
        try
        {
            _viewportModule ??= await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./_content/NexaCRM.UI/js/navigationTailInterop.js");
            var categoryKey = await _viewportModule.InvokeAsync<string>("navigationTail.registerViewportObserver", _dotNetRef);
            return ParseViewportCategory(categoryKey);
        }
        catch (Exception ex)
        {
            try { Logger?.LogDebug(ex, "navigationTail viewport observer init failed"); } catch { }
            return ViewportCategory.Desktop;
        }
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();
        // initialize selectedItem from current URI
        selectedItem = NormalizePath("/" + NavigationManager.ToBaseRelativePath(NavigationManager.Uri));
        NavigationManager.LocationChanged += OnLocationChanged;
    }

    private void OnLocationChanged(object? sender, Microsoft.AspNetCore.Components.Routing.LocationChangedEventArgs e)
    {
        selectedItem = NormalizePath("/" + NavigationManager.ToBaseRelativePath(e.Location));
        _ = InvokeAsync(StateHasChanged);
    }

    private async Task LoadGroupsAsync()
    {
        // Try to get roles from authentication state if available to filter groups
        string[] roles = Array.Empty<string>();
        try
        {
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var user = authState.User;
            if (user?.Identity?.IsAuthenticated == true)
            {
                roles = user.Claims.Where(c => c.Type == ClaimTypes.Role).Select(c => c.Value).ToArray();
            }
        }
        catch { }

        visibleGroups.Clear();
        var roleSet = new HashSet<string>(roles ?? Array.Empty<string>(), StringComparer.OrdinalIgnoreCase);

        foreach (var g in NavigationCatalog.Groups)
        {
            // Filter groups by required roles (if any)
            if (g.RequiredRoles?.Count > 0)
            {
                if (roleSet.Count == 0 || !g.RequiredRoles.Any(r => roleSet.Contains(r)))
                {
                    continue;
                }
            }

            // Build link VMs and localize display names if Localizer is available
            var links = g.Links.Select(l => new NavLinkVm(GetHref(l.Href), Localizer[l.ResourceKey]?.Value ?? l.ResourceKey, l.IconCssClass)).ToList();
            if (links.Count == 0) continue;

            // Map group icon to a more realistic bootstrap icon where appropriate
            var resourceKey = g.ResourceKey ?? string.Empty;
            var mappedIcon = MapIcon(Localizer[resourceKey]?.Value ?? resourceKey, g.IconCssClass);
            // Use a stable key for the group (resource key normalized) to allow safe lookups
            var key = (resourceKey.Length > 0 ? resourceKey : Guid.NewGuid().ToString()).ToLowerInvariant();
            var displayName = Localizer[resourceKey]?.Value ?? resourceKey;
            visibleGroups.Add(new NavGroupVm(key, displayName, mappedIcon, links));
        }

        // Debug: log what groups were built
        try
        {
            var names = string.Join(", ", visibleGroups.Select(v => v.DisplayName));
            _ = JSRuntime.InvokeVoidAsync("console.log", $"NewNavigationTail.LoadGroupsAsync built groups: {names}");
            try { Logger?.LogInformation("NewNavigationTail.LoadGroupsAsync built groups: {Groups}", names); } catch { }
        }
        catch { }

        await HydrateStorageCacheAsync();

        if (activeSubMenuIndex.HasValue && !IsIndexWithinBounds(activeSubMenuIndex.Value))
        {
            activeSubMenuIndex = null;
        }

        if (!activeSubMenuIndex.HasValue)
        {
            var stored = GetStoredIndexForCategory(_currentViewportCategory);
            if (stored.HasValue && IsIndexWithinBounds(stored.Value))
            {
                activeSubMenuIndex = stored.Value;
            }
        }

        if (!activeSubMenuIndex.HasValue && visibleGroups.Count > 0)
        {
            activeSubMenuIndex = 0;
            await SaveActiveIndexToStorageAsync(activeSubMenuIndex);
        }

        if (PanelShouldOverlay && !activeSubMenuIndex.HasValue)
        {
            _overlayPanelHidden = true;
        }
    }

    private bool IsIndexWithinBounds(int index) => index >= 0 && index < visibleGroups.Count;

    private void ToggleCollapse()
    {
        isRailCollapsed = !isRailCollapsed;
    }

    private async Task ToggleSubMenu(int index)
    {
        var newIndex = index;
        await JSRuntime.InvokeVoidAsync("console.log", $"ToggleSubMenu called with index={newIndex}");

        try
        {
            if (!IsIndexWithinBounds(newIndex))
            {
                await JSRuntime.InvokeVoidAsync("console.warn", $"ToggleSubMenu called with out-of-range index={newIndex}");
                return;
            }

            if (activeSubMenuIndex == newIndex)
            {
                if (PanelShouldOverlay)
                {
                    _overlayPanelHidden = !_overlayPanelHidden;
                    await InvokeAsync(StateHasChanged);
                    return;
                }

                activeSubMenuIndex = null;
                _overlayPanelHidden = PanelShouldOverlay;
                await SaveActiveIndexToStorageAsync(activeSubMenuIndex);
                await JSRuntime.InvokeVoidAsync("console.log", "NewNavigationTail.ToggleSubMenu -> index=null, no group");
                try { Logger?.LogInformation("NewNavigationTail.ToggleSubMenu -> {Details}", "index=null, no group"); } catch { }
                await InvokeAsync(StateHasChanged);
                return;
            }

            activeSubMenuIndex = newIndex;
            _overlayPanelHidden = false;
            await InvokeAsync(StateHasChanged);

            // Persist selection to localStorage in background while UI is already updated
            try
            {
                await JSRuntime.InvokeVoidAsync("console.log", $"NewNavigationTail.ToggleSubMenu persisting index={newIndex}");
                await SaveActiveIndexToStorageAsync(activeSubMenuIndex);
                await JSRuntime.InvokeVoidAsync("console.log", "NewNavigationTail.ToggleSubMenu persistence complete");
            }
            catch (Exception persistEx)
            {
                try { Logger?.LogWarning(persistEx, "Failed to persist activeSubMenuIndex"); } catch { }
                await JSRuntime.InvokeVoidAsync("console.warn", $"Failed to persist activeSubMenuIndex: {persistEx.Message}");
            }

            var grp = visibleGroups[newIndex];
            var details = $"index={newIndex}, group={grp.DisplayName}, links={grp.Links.Count}";
            await JSRuntime.InvokeVoidAsync("console.log", "NewNavigationTail.ToggleSubMenu -> " + details);
            try { Logger?.LogInformation("NewNavigationTail.ToggleSubMenu -> {Details}", details); } catch { }
        }
        catch (Exception ex)
        {
            try { Logger?.LogError(ex, "ToggleSubMenu failed"); } catch { }
            Console.WriteLine($"ToggleSubMenu error: {ex}");
        }
    }

    private async Task ToggleSubMenuByKey(string key)
    {
        if (string.IsNullOrWhiteSpace(key)) return;

        try
        {
            var idx = visibleGroups.FindIndex(g => string.Equals(g.Key, key, StringComparison.OrdinalIgnoreCase));
            if (idx < 0)
            {
                await JSRuntime.InvokeVoidAsync("console.warn", $"ToggleSubMenuByKey could not locate key={key}");
                return;
            }

            await ToggleSubMenu(idx);
        }
        catch (Exception ex)
        {
            try { Logger?.LogError(ex, "ToggleSubMenuByKey failed"); } catch { }
            await JSRuntime.InvokeVoidAsync("console.error", $"ToggleSubMenuByKey error: {ex.Message}");
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e, int index)
    {
        if (e == null) return;
        if (e.Key == "Enter" || e.Key == " " || e.Code == "Space")
        {
            await ToggleSubMenu(index);
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e, string key)
    {
        if (e == null) return;
        if (e.Key == "Enter" || e.Key == " " || e.Code == "Space")
        {
            await ToggleSubMenuByKey(key);
        }
    }

    private void SelectItem(string href)
    {
        selectedItem = NormalizePath(href);
        if (PanelShouldOverlay)
        {
            _overlayPanelHidden = true;
        }
        // navigate
        try
        {
            NavigationManager.NavigateTo(href);
        }
        catch { }
    }

    private static string GetHref(string href)
    {
        if (string.IsNullOrWhiteSpace(href)) return "/";
        return href.StartsWith('/') ? href : "/" + href;
    }

    private static string NormalizePath(string? href)
    {
        if (string.IsNullOrWhiteSpace(href)) return "/";

        try
        {
            // If absolute URL provided, extract path component
            if (Uri.TryCreate(href, UriKind.Absolute, out var abs))
            {
                href = abs.PathAndQuery ?? abs.AbsolutePath ?? "/";
            }
        }
        catch { }

        // strip query and fragment
        var qIdx = href.IndexOf('?');
        if (qIdx >= 0) href = href.Substring(0, qIdx);
        var hIdx = href.IndexOf('#');
        if (hIdx >= 0) href = href.Substring(0, hIdx);

        if (!href.StartsWith('/')) href = "/" + href;

        // collapse repeated slashes
        while (href.Contains("//")) href = href.Replace("//", "/");

        // remove trailing slash except for root
        if (href.Length > 1 && href.EndsWith('/')) href = href.TrimEnd('/');

        return href;
    }

    private static string MapIcon(string displayName, string originalIcon)
    {
        if (string.IsNullOrEmpty(displayName)) return originalIcon ?? "default";

        var key = displayName.ToLowerInvariant();
        var result = key switch
        {
            // Dashboard / main overview
            var s when s.Contains("dashboard") || s.Contains("main") || s.Contains("overview") => "graph",

            // Tasks / project boards
            var s when s.Contains("task") || s.Contains("tasks") || s.Contains("todo") || s.Contains("projects") || s.Contains("project") => "kanban",

            // Distribution / allocation visualizations
            var s when s.Contains("distribution") || s.Contains("distribute") => "bar-chart",

            // Scheduling / calendar
            var s when s.Contains("schedule") || s.Contains("schedules") || s.Contains("calendar") => "calendar",

            // Advanced / settings-like pages
            var s when s.Contains("advanced") || s.Contains("advanced") || s.Contains("expert") => "gear",

            var s when s.Contains("sales") || s.Contains("pipeline") => "graph",
            var s when s.Contains("db") || s.Contains("database") || s.Contains("dbmanagement") => "database",
            var s when s.Contains("engagement") || s.Contains("sms") => "chat",
            var s when s.Contains("insight") || s.Contains("reports") || s.Contains("statistics") => "bar-chart",
            var s when s.Contains("setting") || s.Contains("settings") => "gear",
            var s when s.Contains("organization") || s.Contains("org") => "people",
            var s when s.Contains("system") || s.Contains("info") => "cpu",
            _ => "default"
        };

        // If we couldn't map from the display name, attempt to derive a token from
        // the original icon CSS (eg. "bi bi-kanban") passed in as the second
        // parameter to this method. This ensures groups that are localized to
        // arbitrary names still get a sensible icon when the NavigationCatalog
        // carries an icon class.
        if (result == "default")
        {
            var parsed = FallbackParseIcon(originalIcon);
            if (parsed != "default") return parsed;
        }

        return result;
    }

    // If mapping by display name fails, attempt to parse the original icon CSS
    // classes (eg. "bi bi-kanban", "fa fa-cog") and extract a reasonable
    // fallback token such as "kanban" or "cog".
    private static string FallbackParseIcon(string? originalIcon)
    {
        if (string.IsNullOrWhiteSpace(originalIcon)) return "default";
        try
        {
            var token = originalIcon.ToLowerInvariant().Split(' ', StringSplitOptions.RemoveEmptyEntries).Last();
            token = token.Replace("bi-", "").Replace("fa-", "").Replace("bi", "").Replace("fa", "").Trim('-', '_');
            return string.IsNullOrEmpty(token) ? "default" : token;
        }
        catch
        {
            return "default";
        }
    }

    private RenderFragment RenderIcon(string iconKey, string? extraClass = null) => builder =>
    {
        // inline small SVGs for icons used in rail and links
    var cls = string.IsNullOrEmpty(extraClass) ? "nav-icon" : $"nav-icon {extraClass}";
    // Normalize incoming icon keys: callers sometimes pass CSS classes like
    // "bi bi-kanban" or "fa fa-cog". Extract the most-meaningful token and
    // strip common prefixes so our switch matches expected icon names.
    var rawKey = iconKey ?? "default";
    var svg = rawKey.ToLowerInvariant();
        if (svg.Contains(' ')) svg = svg.Split(' ', StringSplitOptions.RemoveEmptyEntries).Last();
        svg = svg.Replace("bi-", "").Replace("fa-", "").Replace("bi", "").Replace("fa", "").Trim('-','_');

        // Alias common icon tokens (from icon font class names) to our supported
        // inline SVG keys so more items render as icons instead of the fallback circle.
        var alias = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            ["table"] = "database",
            ["person-lines-fill"] = "people",
            ["person-lines"] = "people",
            ["person-circle"] = "people",
            ["person"] = "people",
            ["calendar-event"] = "calendar",
            ["calendar-day"] = "calendar",
            ["calendar"] = "calendar",
            ["clock-history"] = "graph",
            ["star"] = "star",
            ["x-circle"] = "default",
            ["plus-circle"] = "bar-chart",
            ["clipboard-data"] = "bar-chart",
            ["send"] = "chat",
            ["send-check"] = "chat",
            ["megaphone"] = "chat",
            ["bell"] = "chat",
            ["graph-up"] = "bar-chart",
            ["file-earmark-bar-graph"] = "bar-chart",
            ["hdd-network"] = "cpu",
            ["diagram-3-fill"] = "people",
            ["people-fill"] = "people",
            ["person-fill"] = "people",
            // additional aliases for group icons
            ["briefcase"] = "kanban",
            ["building-fill"] = "people",
            ["building"] = "people",
            ["sliders"] = "gear",
            ["graph-up"] = "bar-chart",
            ["chat-left-text"] = "chat",
            ["send-check"] = "chat",
            ["send"] = "chat",
        };

        if (alias.TryGetValue(svg, out var mapped)) svg = mapped;
        // Wrap shape elements in a <g class='svg-group'> so we can target group-level styles (stroke/fill) from CSS
        string svgHtml = svg switch
        {
            // Kanban / boards: three stacked rectangles (stroke-only)
            "kanban" => "<svg width='20' height='20' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg' aria-hidden='true' focusable='false' role='img'><g class='svg-group' fill='none' stroke='currentColor' stroke-width='1.6' stroke-linecap='round' stroke-linejoin='round'><rect x='3' y='4' width='7' height='16' rx='1.5'/><rect x='10.5' y='4' width='3' height='9' rx='1'/><rect x='15.5' y='11' width='5.5' height='9' rx='1.5'/></g></svg>",

            // Graph / sales: axes with polyline for trend
            "graph" => "<svg width='20' height='20' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg' aria-hidden='true' focusable='false' role='img'><g class='svg-group' fill='none' stroke='currentColor' stroke-width='1.6' stroke-linecap='round' stroke-linejoin='round'><path d='M3 21v-8'/><path d='M3 21h18'/><polyline points='7 13 11 9 15 15 21 7'/></g></svg>",

            // Database: stacked ellipses, stroke-only for clarity
            "database" => "<svg width='20' height='20' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg' aria-hidden='true' focusable='false' role='img'><g class='svg-group' fill='none' stroke='currentColor' stroke-width='1.6' stroke-linecap='round' stroke-linejoin='round'><ellipse cx='12' cy='6' rx='8' ry='2.5'/><path d='M4 6v6c0 1.4 3.6 2.5 8 2.5s8-1.1 8-2.5V6'/><path d='M4 12c0 1.4 3.6 2.5 8 2.5s8-1.1 8-2.5' stroke-width='1.2'/></g></svg>",

            // Chat / engagement: rounded bubble stroke-only
            "chat" => "<svg width='20' height='20' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg' aria-hidden='true' focusable='false' role='img'><g class='svg-group' fill='none' stroke='currentColor' stroke-width='1.6' stroke-linecap='round' stroke-linejoin='round'><path d='M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z'/></g></svg>",

            // Bar chart: 3 vertical bars
            "bar-chart" => "<svg width='20' height='20' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg' aria-hidden='true' focusable='false' role='img'><g class='svg-group' fill='none' stroke='currentColor' stroke-width='1.6' stroke-linecap='round' stroke-linejoin='round'><rect x='4' y='10' width='3.5' height='10' rx='0.6'/><rect x='10.25' y='5' width='3.5' height='15' rx='0.6'/><rect x='16.5' y='14' width='3.5' height='6' rx='0.6'/></g></svg>",

            // Gear / settings: simplified cog (circle + spokes)
            "gear" => "<svg width='20' height='20' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg' aria-hidden='true' focusable='false' role='img'><g class='svg-group' fill='none' stroke='currentColor' stroke-width='1.4' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='3.2' stroke-width='1.5'/><path d='M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33'/><path d='M4.6 9a1.65 1.65 0 0 1-.33-1.82l-.06-.06A2 2 0 0 0 6.9 3.29l.06.06a1.65 1.65 0 0 1 1.82.33'/></g></svg>",

            _ => "<svg width='20' height='20' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg' aria-hidden='true' focusable='false' role='img'><g class='svg-group' fill='none' stroke='currentColor' stroke-width='1.6' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='6.5'/></g></svg>"
        };

        builder.OpenElement(0, "span");
        builder.AddAttribute(1, "class", cls);
        builder.AddMarkupContent(2, svgHtml);
        builder.CloseElement();
    };

    private record LinkSubgroup(string Title, List<NavLinkVm> Links);

    private static List<LinkSubgroup> GroupLinks(List<NavLinkVm> links)
    {
        var groups = new Dictionary<string, List<NavLinkVm>>(StringComparer.OrdinalIgnoreCase);
        foreach (var l in links)
        {
            // group by first URL segment
            var href = l.Href ?? "/";
            var parts = href.TrimStart('/').Split('/', StringSplitOptions.RemoveEmptyEntries);
            string seg;
            // If this looks like a db/database route, include the second segment to separate functions
            if (parts.Length >= 2 && (string.Equals(parts[0], "db", StringComparison.OrdinalIgnoreCase) || string.Equals(parts[0], "database", StringComparison.OrdinalIgnoreCase)))
            {
                seg = parts[0] + "/" + parts[1];
            }
            else
            {
                seg = parts.FirstOrDefault() ?? "/";
            }
            if (!groups.TryGetValue(seg, out var list))
            {
                list = new List<NavLinkVm>();
                groups[seg] = list;
            }
            list.Add(l);
        }

        // Convert to ordered list preserving original order within subgroup
        var result = groups.Select(g => new LinkSubgroup(g.Key, g.Value)).ToList();
        return result;
    }

    private void ToggleSubgroup(string subgroupKey)
    {
        if (string.IsNullOrEmpty(subgroupKey)) return;
        if (openSubgroups.Contains(subgroupKey)) openSubgroups.Remove(subgroupKey);
        else openSubgroups.Add(subgroupKey);
        _ = InvokeAsync(StateHasChanged);
    }

    private string ToFriendlyGroupTitle(string raw)
    {
        if (string.IsNullOrWhiteSpace(raw)) return string.Empty;
        var key = raw.Trim();
        // If group key contains '/', prefer the last segment for the display title
        if (key.Contains('/'))
        {
            var parts = key.Split('/', StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length > 0) key = parts.Last();
        }

        // Prefer localized resource if available
        try
        {
            var localized = Localizer?[key];
            if (!string.IsNullOrEmpty(localized)) return localized;
        }
        catch { }

        // Mapping table for common catalog keys
        var map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            ["products"] = "Products",
            ["orders"] = "Orders",
            ["subscriptions"] = "Subscriptions",
            ["customers"] = "Customers",
            ["discounts"] = "Discounts",
            ["licenses"] = "Licenses",
            ["store"] = "Store",
        };

        if (map.TryGetValue(key, out var mapped)) return mapped;

        // Fallback: title-case and replace dashes/underscores
        var cleaned = key.ToLowerInvariant().Replace('-', ' ').Replace('_', ' ');
        return System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(cleaned);
    }

    private async Task HydrateStorageCacheAsync()
    {
        if (_storageHydrated) return;
        try
        {
            var raw = await JSRuntime.InvokeAsync<string>("localStorage.getItem", StorageKey);
            if (!string.IsNullOrWhiteSpace(raw))
            {
                var snapshot = JsonSerializer.Deserialize<NavigationStorageSnapshot>(raw, StorageSerializerOptions);
                _storageSnapshot = NormalizeSnapshot(snapshot);
            }
            else
            {
                _storageSnapshot = CreateEmptySnapshot();
            }
        }
        catch (Exception ex)
        {
            try { Logger?.LogDebug(ex, "Failed to hydrate navigation storage state"); } catch { }
            _storageSnapshot = CreateEmptySnapshot();
        }
        finally
        {
            _storageHydrated = true;
        }
    }

    private async Task<int?> LoadActiveIndexFromStorageAsync()
    {
        await HydrateStorageCacheAsync();
        return GetStoredIndexForCategory(_currentViewportCategory);
    }

    private int? GetStoredIndexForCategory(ViewportCategory category)
    {
        var key = GetViewportCategoryKey(category);
        return _storageSnapshot.Indices.TryGetValue(key, out var value) ? value : null;
    }

    private async Task SaveActiveIndexToStorageAsync(int? index)
    {
        await HydrateStorageCacheAsync();
        try
        {
            var key = GetViewportCategoryKey(_currentViewportCategory);
            _storageSnapshot.Indices[key] = index;
            _storageSnapshot.ActiveCategory = key;
            var payload = JsonSerializer.Serialize(_storageSnapshot, StorageSerializerOptions);
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", StorageKey, payload);
        }
        catch (Exception ex)
        {
            try { Logger?.LogDebug(ex, "Failed to persist navigation storage state"); } catch { }
        }
    }

    [JSInvokable]
    public async Task OnExternalStorageChange(string? newValue)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(newValue))
            {
                _storageSnapshot = CreateEmptySnapshot();
                _storageHydrated = true;
                activeSubMenuIndex = null;
                if (PanelShouldOverlay)
                {
                    _overlayPanelHidden = true;
                }
            }
            else
            {
                var snapshot = JsonSerializer.Deserialize<NavigationStorageSnapshot>(newValue, StorageSerializerOptions);
                _storageSnapshot = NormalizeSnapshot(snapshot);
                _storageHydrated = true;

                var stored = GetStoredIndexForCategory(_currentViewportCategory);
                if (stored.HasValue && IsIndexWithinBounds(stored.Value))
                {
                    activeSubMenuIndex = stored.Value;
                    if (PanelShouldOverlay)
                    {
                        _overlayPanelHidden = false;
                    }
                }
                else if (!stored.HasValue)
                {
                    activeSubMenuIndex = null;
                    if (PanelShouldOverlay)
                    {
                        _overlayPanelHidden = true;
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"OnExternalStorageChange error: {ex}");
            try { Logger?.LogDebug(ex, "OnExternalStorageChange failed"); } catch { }
        }

        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public Task OnViewportCategoryChanged(string? categoryKey) => ApplyViewportCategoryAsync(ParseViewportCategory(categoryKey));

    private async Task ApplyViewportCategoryAsync(ViewportCategory category, bool isInitial = false)
    {
        if (!isInitial && _currentViewportCategory == category)
        {
            return;
        }

        _currentViewportCategory = category;

        if (!PanelShouldOverlay)
        {
            _overlayPanelHidden = false;
        }
        else if (isInitial && !activeSubMenuIndex.HasValue)
        {
            _overlayPanelHidden = true;
        }

        var stored = await LoadActiveIndexFromStorageAsync();
        if (stored.HasValue && IsIndexWithinBounds(stored.Value))
        {
            activeSubMenuIndex = stored.Value;
            if (PanelShouldOverlay)
            {
                _overlayPanelHidden = false;
            }
        }
        else if (!activeSubMenuIndex.HasValue && visibleGroups.Count > 0)
        {
            activeSubMenuIndex = 0;
            _overlayPanelHidden = PanelShouldOverlay;
            await SaveActiveIndexToStorageAsync(activeSubMenuIndex);
        }
        else if (PanelShouldOverlay && !stored.HasValue)
        {
            _overlayPanelHidden = true;
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task DisposeViewportModuleAsync()
    {
        if (_viewportModule == null) return;
        try
        {
            await _viewportModule.InvokeVoidAsync("navigationTail.dispose");
            await _viewportModule.DisposeAsync();
        }
        catch { }
        _viewportModule = null;
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("navigationStorageSync.unregisterDotNet");
        }
        catch { }

        await DisposeViewportModuleAsync();

        if (_dotNetRef != null)
        {
            _dotNetRef.Dispose();
            _dotNetRef = null;
        }
        try
        {
            NavigationManager.LocationChanged -= OnLocationChanged;
        }
        catch { }
    }

    private string BuildSidebarClasses()
    {
        var classes = new List<string> { "sidebar" };
        if (isRailCollapsed) classes.Add("collapsed");
        if (ShouldShowPanel) classes.Add("panel-open");
        if (PanelShouldOverlay) classes.Add("overlay-mode");
        if (PanelShouldOverlay && _overlayPanelHidden) classes.Add("panel-hidden");
        return string.Join(' ', classes.Where(c => !string.IsNullOrWhiteSpace(c)));
    }

    private void ClosePanelFromHeader()
    {
        if (!PanelShouldOverlay) return;
        _overlayPanelHidden = true;
        _ = InvokeAsync(StateHasChanged);
    }

    private static string GetViewportCategoryKey(ViewportCategory category) => category switch
    {
        ViewportCategory.Mobile => "mobile",
        ViewportCategory.Tablet => "tablet",
        ViewportCategory.Widescreen => "widescreen",
        _ => "desktop"
    };

    private static ViewportCategory ParseViewportCategory(string? category) => category?.ToLowerInvariant() switch
    {
        "mobile" => ViewportCategory.Mobile,
        "tablet" => ViewportCategory.Tablet,
        "widescreen" => ViewportCategory.Widescreen,
        "desktop" => ViewportCategory.Desktop,
        _ => ViewportCategory.Desktop
    };

    private static NavigationStorageSnapshot NormalizeSnapshot(NavigationStorageSnapshot? snapshot)
    {
        if (snapshot == null)
        {
            return CreateEmptySnapshot();
        }

        var indices = snapshot.Indices != null
            ? new Dictionary<string, int?>(snapshot.Indices, StringComparer.OrdinalIgnoreCase)
            : new Dictionary<string, int?>(StringComparer.OrdinalIgnoreCase);

        return new NavigationStorageSnapshot
        {
            ActiveCategory = snapshot.ActiveCategory,
            Indices = indices
        };
    }

    private static NavigationStorageSnapshot CreateEmptySnapshot() => new()
    {
        ActiveCategory = null,
        Indices = new Dictionary<string, int?>(StringComparer.OrdinalIgnoreCase)
    };

    private enum ViewportCategory
    {
        Mobile,
        Tablet,
        Desktop,
        Widescreen
    }

    private sealed class NavigationStorageSnapshot
    {
        [JsonPropertyName("category")]
        public string? ActiveCategory { get; set; }

        [JsonPropertyName("indices")]
        public Dictionary<string, int?> Indices { get; set; } = new(StringComparer.OrdinalIgnoreCase);
    }
}

