@using System
@using System.Linq
@using System.Globalization
@using System.Security.Claims
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Routing
@using NexaCRM.UI.Services.Interfaces
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject Microsoft.Extensions.Logging.ILogger<NavigationTail> Logger
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IRolePermissionService RolePermissionService
@inject IAuthenticationService AuthenticationService
@inject Microsoft.Extensions.Localization.IStringLocalizer<NavMenu> Localizer
@inject ActionInterop ActionInterop
@inject IGlobalActionService GlobalActionService
@using NexaCRM.UI.Models.Navigation
@implements IAsyncDisposable

<div class='sidebar @(isCollapsed ? "collapsed" : "") @(activeSubMenuIndex.HasValue && activeSubMenuIndex.Value >= 0 && activeSubMenuIndex.Value < visibleGroups.Count ? "panel-open" : "")'
     role="navigation"
     data-panel-state='@(isMobilePanelOpen ? "expanded" : "collapsed")'
     data-viewport='@_viewportKey'>
    <div class="sidebar-mobile-header">
        <button type="button"
                class="sidebar-mobile-toggle"
                aria-expanded="@isMobilePanelOpen"
                aria-controls="navigationRailPanel"
                @onclick="ToggleMobilePanel"
                title="@Localizer["ToggleNavigation"]">
            <span class="sidebar-mobile-toggle__icon" aria-hidden="true">☰</span>
            <span class="sidebar-mobile-toggle__label">@Localizer["Navigation"]</span>
        </button>
        <button type="button"
                class="sidebar-mobile-quick-action"
                @onclick="LaunchMobileQuickActionAsync"
                title="@Localizer["OpenQuickActions"]">
            <span class="ui-sr-only">@Localizer["OpenQuickActions"]</span>
            <i class="bi bi-plus-circle"></i>
        </button>
    </div>
    <div class="sidebar-rail">
                <a href="/" class="rail-logo" title="Online store">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128" width="512" height="512" class="rail-logo-img" aria-hidden="true" focusable="false" role="img">
                            <defs>
                                <linearGradient id="fancyDiamondGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#374151;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#111827;stop-opacity:1" />
                                </linearGradient>
                
                                <linearGradient id="fancyNGrad" x1="0%" y1="100%" x2="100%" y2="0%">
                                    <stop offset="0%" style="stop-color:#2DD4BF;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#A5F3FC;stop-opacity:1" />
                                </linearGradient>
                
                                <linearGradient id="fancySparkGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:#F472B6;stop-opacity:1" />
                                    <stop offset="50%" style="stop-color:#38BDF8;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#34D399;stop-opacity:1" />
                                </linearGradient>

                                <filter id="softShadow" x="-50%" y="-50%" width="200%" height="200%">
                                    <feGaussianBlur in="SourceAlpha" stdDeviation="2" result="blur" />
                                    <feOffset in="blur" dx="2" dy="4" result="offsetBlur" />
                                    <feComponentTransfer>
                                        <feFuncA type="linear" slope="0.3" />
                                    </feComponentTransfer>
                                    <feMerge>
                                        <feMergeNode />
                                        <feMergeNode in="SourceGraphic" />
                                    </feMerge>
                                </filter>
                            </defs>

                            <g filter="url(#softShadow)">
                                <path fill="url(#fancyDiamondGrad)" d="m125.2 54.8-52-52L71.3.9 69.2 0H58.8l-2.1.9-1.9 1.9-52 52-1.9 1.9-.9 2.1v10.3l.9 2.1 1.9 1.9 52 52 1.9 1.9 2.1.9h10.3l2.1-.9 1.9-1.9 52-52 1.9-1.9.9-2.1V58.8l-.9-2.1-1.8-1.9z"></path>
                
                                <path fill="url(#fancyNGrad)" d="M78.9 80.5H71l-.7-.7V61.3c0-3.3-1.3-5.9-5.3-6-2-.1-4.4 0-6.9.1l-.4.4v24l-.7.7h-7.9l-.7-.7V48.1l.7-.7H67c6.9 0 12.6 5.6 12.6 12.6v19.8l-.7.7z"></path>
                
                                <path fill="url(#fancySparkGrad)" d="m38.4 30.8 7.3 7.3v5.8l-.8.8h-5.8l-7.3-7.3v-1.1l5.5-5.5h1.1zm.2 37.2v-8l-.7-.7h-28l-.7.7v8l.7.7H38l.6-.7zm.5 15.7L31.8 91v1.1l5.5 5.5h1.1l7.3-7.3v-5.8l-.8-.8h-5.8zM60 11.3l-.6.7v25l.7.7H68l.7-.7V12l-.7-.7h-8zm0 79.1-.7.7v25l.7.7h8l.7-.7v-25l-.7-.7h-8zm58.1-31h-28l-.7.6v8l.7.7h28.1l.7-.7v-8l-.8-.6z"></path>
                            </g>
                        </svg>
                </a>

        <ul class="rail-list">
            @for (var i = 0; i < visibleGroups.Count; i++)
            {
                var g = visibleGroups[i];
                var tooltip = g.DisplayName;

                // Only render the dashboard and db-related groups in the rail for this change.
                // Keys are stored in lowercase when groups are built, so check lowercase tokens.
                <li>
                    <button role="tab" class="rail-btn @(activeSubMenuIndex == i ? "active" : "")"
                            title="@tooltip"
                            aria-label="@tooltip"
                            aria-selected="@(activeSubMenuIndex == i ? "true" : "false")"
                            tabindex="0"
                            @onclick="async () => await ToggleSubMenuByKey(g.Key)"
                            @onkeydown="async (e) => await HandleKeyDown(e, g.Key)">
                        @RenderIcon(g.IconCss, "rail-icon")
                    </button>
                </li>
            }
        </ul>

        <div class="rail-footer">
            <button class="rail-avatar" title="Profile">
                <img src="https://localhost:7065/_content/NexaCRM.UI/images/avatar.png" alt="avatar" />
            </button>
        </div>
    </div>

    <div id="navigationRailPanel" class='sidebar-panel @(activeSubMenuIndex.HasValue && activeSubMenuIndex.Value >= 0 && activeSubMenuIndex.Value < visibleGroups.Count ? "open" : "")'>
        <div class="panel-header">
            <div class="panel-title">Online store</div>
            <div class="panel-subtitle">Untitled UI</div>
        </div>

        <div class="panel-body">
            @{ var hasValidIndex = activeSubMenuIndex.HasValue && activeSubMenuIndex.Value >= 0 && activeSubMenuIndex.Value < visibleGroups.Count; }
            @if (!hasValidIndex)
            {
                <div class="panel-empty">Select a menu item</div>
            }
            else
            {
                var grp = visibleGroups[activeSubMenuIndex.Value];
                // For the consolidated dashboard group we inserted, render the
                // three dashboard links as a single subgroup so they appear under
                // the DASHBOARD header instead of as separate subgroup headings.
                List<LinkSubgroup> grouped;
                if (string.Equals(grp.Key, "dashboard", StringComparison.OrdinalIgnoreCase))
                {
                    grouped = new List<LinkSubgroup> { new LinkSubgroup("dashboard", grp.Links) };
                }
                else
                {
                    grouped = GroupLinks(grp.Links);
                }
                @foreach (var sub in grouped)
                {
                        var hasActiveInSub = sub.Links.Any(l => string.Equals(NormalizePath(l.Href), selectedItem, StringComparison.OrdinalIgnoreCase));
                        <div class="panel-subgroup @(hasActiveInSub ? "subgroup-has-active" : "")">
                            <div class="panel-subgroup-title">
                                @{
                                    // Choose an icon for the subgroup title. Prefer a mapping based on
                                    // the friendly title; fall back to the first link's IconCss if present.
                                    var friendly = ToFriendlyGroupTitle(sub.Title);
                                    var firstIcon = sub.Links.FirstOrDefault()?.IconCss;
                                    var titleIconKey = MapIcon(friendly, firstIcon ?? string.Empty);
                                    // Determine expansion state: keep expanded if it contains an active
                                    // link, or the user explicitly expanded it.
                                    var isExpanded = hasActiveInSub || openSubgroups.Contains(sub.Title);
                                }
                                @RenderIcon(titleIconKey, "group-title-icon")
                                <span class="group-title-text">@friendly</span>

                                <button class="subgroup-toggler" aria-expanded="@isExpanded" @onclick="() => ToggleSubgroup(sub.Title)" title="Toggle details">
                                    @((MarkupString)(isExpanded ? "&minus;" : "+"))
                                </button>
                            </div>
                            <ul class="panel-list @(isExpanded ? "" : "collapsed")">
                                @foreach (var link in sub.Links)
                                {
                                    var isActive = string.Equals(NormalizePath(link.Href), selectedItem, StringComparison.OrdinalIgnoreCase);
                                    <li class='@(isActive ? "item-active" : "")'>
                                        <a href="@link.Href" class='@(isActive ? "active page-active" : "")' @onclick='() => SelectItem(link.Href)'>
                                            <span class="link-text">@link.DisplayName</span>
                                        </a>
                                    </li>
                                }
                            </ul>
                        </div>
                }
            }
        </div>

        <div class="panel-footer">
                <div class="profile-card">
                <img src="https://localhost:7065/_content/NexaCRM.UI/images/avatar.png" alt="User Avatar" />
                <div class="profile-info">
                    <div class="profile-name">Sophia Munn</div>
                    <div class="profile-email">sophia@untitledui.com</div>
                </div>
            </div>
        </div>
    </div>
    @if (isMobilePanelOpen)
    {
        <button type="button" class="sidebar-overlay" aria-hidden="true" @onclick="ToggleMobilePanel"></button>
    }
</div>

@code {
    private bool isCollapsed;
    private int? activeSubMenuIndex;
    private string? selectedItem = null;
    private DotNetObjectReference<NavigationTail>? _dotNetRef;
    private bool isMobilePanelOpen;
    private string _viewportKey = "desktop";
    private const string StorageKeyPrefix = "nexacrm.activeSubMenuIndex";

    private string StorageKey => string.Create(CultureInfo.InvariantCulture, $"{StorageKeyPrefix}.{_viewportKey}");

    private readonly List<NavGroupVm> visibleGroups = new();
    private string lastBuiltGroupNames = string.Empty;
    // Track which subgroups are expanded in the panel. Keys are the subgroup.Title values
    // produced by GroupLinks (eg. first path segment or db/... keys).
    private readonly HashSet<string> openSubgroups = new(StringComparer.OrdinalIgnoreCase);

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        // Load initial groups based on current authentication state
        await LoadGroupsAsync();

        // Ensure we refresh groups when authentication state changes (e.g., user logs in/out)
        try
        {
            AuthenticationStateProvider.AuthenticationStateChanged += OnAuthenticationStateChanged;
        }
        catch { }
    }

    private async Task LoadGroupsAsync()
    {
        try
        {
            Console.WriteLine("NavigationTail.LoadGroupsAsync START");
        }
        catch { }
        // Try to get roles from authentication state if available to filter groups.
        // Expand claim-type checks to cover common JWT/Identity conventions ("role", "roles",
        // ClaimTypes.Role and any claim type that ends with '/role') so roles provided by different
        // auth systems are recognized.
        string[] roles = Array.Empty<string>();
        try
        {
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var user = authState.User;
            if (user?.Identity?.IsAuthenticated == true)
            {
                roles = user.Claims
                    .Where(c =>
                        string.Equals(c.Type, ClaimTypes.Role, StringComparison.OrdinalIgnoreCase)
                        || string.Equals(c.Type, "role", StringComparison.OrdinalIgnoreCase)
                        || string.Equals(c.Type, "roles", StringComparison.OrdinalIgnoreCase)
                        || (c.Type?.EndsWith("/role", StringComparison.OrdinalIgnoreCase) ?? false))
                    .Select(c => c.Value)
                    .Where(v => !string.IsNullOrWhiteSpace(v))
                    .ToArray();

                // As a last resort, if no explicit role claims found but the principal exposes
                // IsInRole information via authentication schemes, attempt a few common roles
                // heuristically (optional — keep roles empty rather than guessing).
            }
        }
        catch { }

        visibleGroups.Clear();
        var roleSet = new HashSet<string>(roles ?? Array.Empty<string>(), StringComparer.OrdinalIgnoreCase);

        foreach (var g in NavigationCatalog.Groups)
        {
            // Previously we filtered out groups whose required roles were missing. To surface every
            // available menu (per UX request) we now keep them all visible regardless of role claims.

            // Build link VMs and localize display names if Localizer is available
            var links = g.Links.Select(l => new NavLinkVm(GetHref(l.Href), Localizer[l.ResourceKey]?.Value ?? l.ResourceKey, l.IconCssClass)).ToList();
            if (links.Count == 0) continue;

            // Map group icon to a more realistic bootstrap icon where appropriate
            var resourceKey = g.ResourceKey ?? string.Empty;
            var mappedIcon = MapIcon(Localizer[resourceKey]?.Value ?? resourceKey, g.IconCssClass);
            // Use a stable key for the group (resource key normalized) to allow safe lookups
            var key = (resourceKey.Length > 0 ? resourceKey : Guid.NewGuid().ToString()).ToLowerInvariant();
            var displayName = Localizer[resourceKey]?.Value ?? resourceKey;
            visibleGroups.Add(new NavGroupVm(key, displayName, mappedIcon, links));
        }

            try
            {
                try
                {
                    _ = JSRuntime.InvokeVoidAsync("localStorage.removeItem", StorageKey);
                }
                catch { }
            }
            catch { }

            // Debug: log what groups were built
            try
            {
                var names = string.Join(", ", visibleGroups.Select(v => v.DisplayName));
                lastBuiltGroupNames = names ?? string.Empty;
                _ = JSRuntime.InvokeVoidAsync("console.log", $"NavigationTail.LoadGroupsAsync built groups: {names}");
                try { Logger?.LogInformation("NavigationTail.LoadGroupsAsync built groups: {Groups}", names); } catch { }
                try { Console.WriteLine($"NavigationTail.LoadGroupsAsync built groups: {names}"); } catch { }
            }
            catch (Exception ex)
            {
                try { Console.WriteLine($"NavigationTail.LoadGroupsAsync debug logging failed: {ex}"); } catch { }
            }

            try
            {
                Console.WriteLine("NavigationTail.LoadGroupsAsync END");
            }
            catch { }

        // Ensure the active index remains valid after rebuilding groups
        if (activeSubMenuIndex.HasValue)
        {
            if (activeSubMenuIndex.Value < 0 || activeSubMenuIndex.Value >= visibleGroups.Count)
            {
                activeSubMenuIndex = null;
            }
        }
        else
        {
            // If there's no active index, but localStorage has one, try to restore it
            try
            {
                var stored = await LoadActiveIndexFromStorageAsync();
                if (stored.HasValue && stored.Value >= 0 && stored.Value < visibleGroups.Count)
                {
                    activeSubMenuIndex = stored.Value;
                }
            }
            catch { }
        }

        // If still no active index, default to first visible group
        if (!activeSubMenuIndex.HasValue && visibleGroups.Count > 0)
        {
            activeSubMenuIndex = 0;
            _ = SaveActiveIndexToStorageAsync(activeSubMenuIndex);
        }
    }

    private void ToggleCollapse()
    {
        isCollapsed = !isCollapsed;
    }

    private void ToggleMobilePanel()
    {
        isMobilePanelOpen = !isMobilePanelOpen;
    }

    private async Task LaunchMobileQuickActionAsync()
    {
        try
        {
            isMobilePanelOpen = false;
            await GlobalActionService.LaunchAsync(new GlobalActionRequest(GlobalActionType.AddContact));
        }
        catch (Exception ex)
        {
            try { Logger?.LogError(ex, "LaunchMobileQuickActionAsync failed"); } catch { }
        }
        finally
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ToggleSubMenu(int index)
    {
        // Capture incoming index immediately to avoid races with async work
        var newIndex = index;
        await JSRuntime.InvokeVoidAsync("console.log", $"ToggleSubMenu called with index={newIndex}");

        try
        {
            // Determine the target index in a local variable first
            int? targetIndex;

            // If clicking the already-active index, we will clear it
            if (activeSubMenuIndex == newIndex)
            {
                targetIndex = null;
            }
            else
            {
                // Only set if the index is within the current visibleGroups bounds
                if (newIndex >= 0 && newIndex < visibleGroups.Count)
                {
                    targetIndex = newIndex;
                }
                else
                {
                    // Out of range: ignore the toggle and keep current state
                    await JSRuntime.InvokeVoidAsync("console.warn", $"ToggleSubMenu called with out-of-range index={newIndex}");
                    return;
                }
            }

            // Capture group details for logging BEFORE any awaits so they reflect intended target
            string details;
            if (targetIndex.HasValue)
            {
                var grp = visibleGroups[targetIndex.Value];
                details = $"index={targetIndex.Value}, group={grp.DisplayName}, links={grp.Links.Count}";
            }
            else
            {
                details = "index=null, no group";
            }

            // Apply the state change immediately so the UI reflects the click right away
            activeSubMenuIndex = targetIndex;
            await InvokeAsync(StateHasChanged);

            // Persist selection to localStorage in background while UI is already updated
            try
            {
                await JSRuntime.InvokeVoidAsync("console.log", $"NavigationTail.ToggleSubMenu persisting index={(targetIndex.HasValue ? targetIndex.Value.ToString() : "null")}");
                await SaveActiveIndexToStorageAsync(targetIndex);
                await JSRuntime.InvokeVoidAsync("console.log", "NavigationTail.ToggleSubMenu persistence complete");
            }
            catch (Exception persistEx)
            {
                try { Logger?.LogWarning(persistEx, "Failed to persist activeSubMenuIndex"); } catch { }
                await JSRuntime.InvokeVoidAsync("console.warn", $"Failed to persist activeSubMenuIndex: {persistEx.Message}");
            }

            // Log out the final decision
            await JSRuntime.InvokeVoidAsync("console.log", "NavigationTail.ToggleSubMenu -> " + details);
            try { Logger?.LogInformation("NavigationTail.ToggleSubMenu -> {Details}", details); } catch { }

            // ensure UI updates
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            try { Logger?.LogError(ex, "ToggleSubMenu failed"); } catch { }
            Console.WriteLine($"ToggleSubMenu error: {ex}");
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e, int index)
    {
        if (e == null) return;
        if (e.Key == "Enter" || e.Key == " " || e.Code == "Space")
        {
            await ToggleSubMenu(index);
        }
    }

    private void SelectItem(string href)
    {
        selectedItem = NormalizePath(href);
        isMobilePanelOpen = false;
        // navigate
        try
        {
            NavigationManager.NavigateTo(href);
        }
        catch { }
    }

    private static string GetHref(string href)
    {
        if (string.IsNullOrWhiteSpace(href)) return "/";
        return href.StartsWith('/') ? href : "/" + href;
    }

    private static string NormalizePath(string? href)
    {
        if (string.IsNullOrWhiteSpace(href)) return "/";

        try
        {
            // If absolute URL provided, extract path component
            if (Uri.TryCreate(href, UriKind.Absolute, out var abs))
            {
                href = abs.PathAndQuery ?? abs.AbsolutePath ?? "/";
            }
        }
        catch { }

        // strip query and fragment
        var qIdx = href.IndexOf('?');
        if (qIdx >= 0) href = href.Substring(0, qIdx);
        var hIdx = href.IndexOf('#');
        if (hIdx >= 0) href = href.Substring(0, hIdx);

        if (!href.StartsWith('/')) href = "/" + href;

        // collapse repeated slashes
        while (href.Contains("//")) href = href.Replace("//", "/");

        // remove trailing slash except for root
        if (href.Length > 1 && href.EndsWith('/')) href = href.TrimEnd('/');

        return href;
    }

    private static string MapIcon(string displayName, string originalIcon)
    {
        if (string.IsNullOrEmpty(displayName)) return originalIcon ?? "default";

        var key = displayName.ToLowerInvariant();
        var result = key switch
        {
            // Dashboard / main overview
            var s when s.Contains("dashboard") || s.Contains("main") || s.Contains("overview") => "graph",

            // Tasks / project boards
            var s when s.Contains("task") || s.Contains("tasks") || s.Contains("todo") || s.Contains("projects") || s.Contains("project") => "kanban",

            // Distribution / allocation visualizations
            var s when s.Contains("distribution") || s.Contains("distribute") => "bar-chart",

            // Scheduling / calendar
            var s when s.Contains("schedule") || s.Contains("schedules") || s.Contains("calendar") => "calendar",

            // Advanced / settings-like pages
            var s when s.Contains("advanced") || s.Contains("advanced") || s.Contains("expert") => "gear",

            var s when s.Contains("sales") || s.Contains("pipeline") => "graph",
            var s when s.Contains("db") || s.Contains("database") || s.Contains("dbmanagement") => "database",
            var s when s.Contains("engagement") || s.Contains("sms") => "chat",
            var s when s.Contains("insight") || s.Contains("reports") || s.Contains("statistics") => "bar-chart",
            var s when s.Contains("setting") || s.Contains("settings") => "gear",
            var s when s.Contains("organization") || s.Contains("org") => "people",
            var s when s.Contains("system") || s.Contains("info") => "cpu",
            _ => "default"
        };

        // If we couldn't map from the display name, attempt to derive a token from
        // the original icon CSS (eg. "bi bi-kanban") passed in as the second
        // parameter to this method. This ensures groups that are localized to
        // arbitrary names still get a sensible icon when the NavigationCatalog
        // carries an icon class.
        if (result == "default")
        {
            var parsed = FallbackParseIcon(originalIcon);
            if (parsed != "default") return parsed;
        }

        return result;
    }

    // If mapping by display name fails, attempt to parse the original icon CSS
    // classes (eg. "bi bi-kanban", "fa fa-cog") and extract a reasonable
    // fallback token such as "kanban" or "cog".
    private static string FallbackParseIcon(string? originalIcon)
    {
        if (string.IsNullOrWhiteSpace(originalIcon)) return "default";
        try
        {
            var token = originalIcon.ToLowerInvariant().Split(' ', StringSplitOptions.RemoveEmptyEntries).Last();
            token = token.Replace("bi-", "").Replace("fa-", "").Replace("bi", "").Replace("fa", "").Trim('-', '_');
            return string.IsNullOrEmpty(token) ? "default" : token;
        }
        catch
        {
            return "default";
        }
    }

    private RenderFragment RenderIcon(string iconKey, string? extraClass = null) => builder =>
    {
        // inline small SVGs for icons used in rail and links
        var cls = string.IsNullOrEmpty(extraClass) ? "nav-icon" : $"nav-icon {extraClass}";
        // Normalize incoming icon keys: callers sometimes pass CSS classes like
        // "bi bi-kanban" or "fa fa-cog". Extract the most-meaningful token and
        // strip common prefixes so our switch matches expected icon names.
        var rawKey = iconKey ?? "default";
        var svg = rawKey.ToLowerInvariant();
        if (svg.Contains(' ')) svg = svg.Split(' ', StringSplitOptions.RemoveEmptyEntries).Last();
        svg = svg.Replace("bi-", "").Replace("fa-", "").Replace("bi", "").Replace("fa", "").Trim('-','_');

        // Alias common icon tokens (from icon font class names) to our supported
        // inline SVG keys so more items render as icons instead of the fallback circle.
        var alias = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            //additional aliases for rail icons 
            ["table"] = "database",
            ["person-lines-fill"] = "people",
            ["person-lines"] = "people",
            ["person-circle"] = "people",
            ["person"] = "people",
            ["calendar-event"] = "calendar",
            ["calendar-day"] = "calendar",
            ["calendar"] = "calendar",
            ["clock-history"] = "graph",
            ["star"] = "star",
            ["x-circle"] = "default",
            ["plus-circle"] = "bar-chart",
            ["clipboard-data"] = "bar-chart",
            ["send"] = "chat",
            ["send-check"] = "chat",
            ["megaphone"] = "chat",
            ["bell"] = "chat",
            ["graph-up"] = "bar-chart",
            ["file-earmark-bar-graph"] = "bar-chart",
            ["hdd-network"] = "cpu",
            ["diagram-3-fill"] = "people",
            ["people-fill"] = "people",
            ["person-fill"] = "people",
            ["workspace"] = "workspace",
            // additional aliases for group icons
            ["briefcase"] = "kanban",
            ["building-fill"] = "people",
            ["building"] = "people",
            ["sliders"] = "gear",
            ["graph-up"] = "bar-chart",
            ["chat-left-text"] = "chat",
            ["send-check"] = "chat",
            ["send"] = "chat",
        };

        if (alias.TryGetValue(svg, out var mapped)) svg = mapped;
        // Wrap shape elements in a <g class='svg-group'> so we can target group-level styles (stroke/fill) from CSS
        string svgHtml = svg switch
        {
            // Workspace (기존 승인된 버전): 팀 협업 공간
"workspace" => "<svg width='40' height='40' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg' stroke='currentColor' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'><rect x='3' y='3' width='7' height='7' rx='1.5'/><rect x='14' y='3' width='7' height='7' rx='1.5'/><rect x='14' y='14' width='7' height='7' rx='1.5'/><path d='M3 14h7v7H3z'/></svg>",   
            
            // Kanban: 보드와 명확한 카드 이동 느낌
            "kanban" => "<svg width='40' height='40' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg' stroke='currentColor' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'><path d='M3 5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5z'/><path d='M9 3v18'/><path d='M15 3v18'/></svg>",
            
            // Graph: 상승하는 트렌드와 데이터 포인트 강조 (매출/실적)
"graph" => "<svg width='40' height='40' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg' stroke='currentColor' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'><path d='M3 21h18'/><path d='M3 18v-4'/><path d='M7 14l4-4 4 4 6-6'/><circle cx='21' cy='8' r='2'/></svg>",
            // Database (기존 승인된 버전): 고객 정보 관리
"database" => "<svg width='40' height='40' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg' stroke='currentColor' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'><ellipse cx='16' cy='6' rx='5' ry='2'/><path d='M11 6v4c0 1.1 2.2 2 5 2s5-.9 5-2V6'/><path d='M11 14v4c0 1.1 2.2 2 5 2s5-.9 5-2v-4'/><path d='M3 20v-2c0-1.7 1.3-3 3-3h2'/><circle cx='6' cy='10' r='3'/></svg>",            
            // Chat: 양방향 소통(Engagement) 강조를 위한 두 개의 말풍선
            "chat" => "<svg width='40' height='40' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg' stroke='currentColor' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'><path d='M14 9a2 2 0 0 1-2 2H6l-4 4V4a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v5'/><path d='M18 9h-4'/><path d='M22 14a2 2 0 0 1-2 2h-6l-4 4V11a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v3z'/></svg>", 

            // Bar-chart: 더 꽉 차고 균형 잡힌 비교 차트
"bar-chart" => "<svg width='40' height='40' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg' stroke='currentColor' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'><path d='M18 20V10'/><path d='M12 20V4'/><path d='M6 20v-6'/><path d='M3 20h18'/></svg>",
            // Gear: 더 견고하고 기계적인 설정 아이콘
"gear" => "<svg width='40' height='40' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg' stroke='currentColor' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='3'/><path d='M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z'/></svg>",
            // People: '팀' 또는 '조직' 느낌을 주기 위해 3명 배치
"people" => "<svg width='40' height='40' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg' stroke='currentColor' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'><path d='M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2'/><circle cx='9' cy='7' r='4'/><path d='M22 21v-2a4 4 0 0 0-3-3.87'/><path d='M16 3.13a4 4 0 0 1 0 7.75'/></svg>",
            // CPU: 시스템 연동/API 느낌의 반도체 칩
"cpu" => "<svg width='40' height='40' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg' stroke='currentColor' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'><rect x='4' y='4' width='16' height='16' rx='2'/><rect x='9' y='9' width='6' height='6'/><path d='M9 1v3'/><path d='M15 1v3'/><path d='M9 20v3'/><path d='M15 20v3'/><path d='M20 9h3'/><path d='M20 14h3'/><path d='M1 9h3'/><path d='M1 14h3'/></svg>",
            // Check: 원형 체크박스로 '완료' 상태를 명확히 표현
            "check" => "<svg width='40' height='40' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M22 11.08V12a10 10 0 1 1-5.93-9.14'/><path d='M22 4L12 14.01l-3-3'/></svg>",

            // Star: 중요/즐겨찾기 (약간 둥글려 부드러운 느낌)
            "star" => "<svg width='40' height='40' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polygon points='12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2'/></svg>",

            // Calendar: 일정 관리 (오늘 날짜나 중요 일정이 있는 느낌)
            "calendar" => "<svg width='40' height='40' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><rect x='3' y='4' width='18' height='18' rx='2' ry='2'/><path d='M16 2v4'/><path d='M8 2v4'/><path d='M3 10h18'/><path d='M8 14h.01'/><path d='M12 14h.01'/><path d='M16 14h.01'/><path d='M8 18h.01'/><path d='M12 18h.01'/><path d='M16 18h.01'/></svg>",
            
            // Default: a distinct outline circle (stroke-only) as fallback
            _ => "<svg width='20' height='20' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg' aria-hidden='true' focusable='false' role='img'><g class='svg-group' fill='none' stroke='currentColor' stroke-width='1.6'><circle cx='12' cy='12' r='9'/></g></svg>"
        };

        builder.OpenElement(0, "span");
        builder.AddAttribute(1, "class", cls);
        builder.AddMarkupContent(2, svgHtml);
        builder.CloseElement();
    };

    private sealed record NavGroupVm(string Key, string DisplayName, string IconCss, List<NavLinkVm> Links);
    private sealed record NavLinkVm(string Href, string DisplayName, string IconCss);

    private async Task ToggleSubMenuByKey(string key)
    {
        if (string.IsNullOrEmpty(key)) return;

        // Resolve index for key from the current visibleGroups snapshot
        var idx = visibleGroups.FindIndex(g => string.Equals(g.Key, key, StringComparison.OrdinalIgnoreCase));
        if (idx < 0)
        {
            await JSRuntime.InvokeVoidAsync("console.warn", $"ToggleSubMenuByKey: no group found for key={key}");
            return;
        }

        try
        {
            // If already active, clear; otherwise set immediately
            if (activeSubMenuIndex.HasValue && activeSubMenuIndex.Value == idx)
            {
                activeSubMenuIndex = null;
                await InvokeAsync(StateHasChanged);
                _ = SaveActiveIndexToStorageAsync(null);
                await JSRuntime.InvokeVoidAsync("console.log", $"ToggleSubMenuByKey cleared index for key={key}");
                return;
            }

            // Set immediately for responsive UI
            activeSubMenuIndex = idx;
            await InvokeAsync(StateHasChanged);

            // Capture details for logging
            var grp = visibleGroups[idx];
            var details = $"index={idx}, group={grp.DisplayName}, links={grp.Links.Count}";
            await JSRuntime.InvokeVoidAsync("console.log", "NavigationTail.ToggleSubMenuByKey -> " + details);

            // Persist selection in background
            _ = SaveActiveIndexToStorageAsync(activeSubMenuIndex);
        }
        catch (Exception ex)
        {
            try { Logger?.LogError(ex, "ToggleSubMenuByKey failed"); } catch { }
            await JSRuntime.InvokeVoidAsync("console.error", $"ToggleSubMenuByKey error: {ex.Message}");
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e, string key)
    {
        if (e == null) return;
        if (e.Key == "Enter" || e.Key == " " || e.Code == "Space")
        {
            await ToggleSubMenuByKey(key);
        }
    }

    private async Task<int?> LoadActiveIndexFromStorageAsync()
    {
        try
        {
            var raw = await JSRuntime.InvokeAsync<string>("localStorage.getItem", StorageKey);
            if (!string.IsNullOrEmpty(raw) && int.TryParse(raw, out var idx)) return idx;
        }
        catch { }

        return null;
    }

    private async Task SaveActiveIndexToStorageAsync(int? index)
    {
        try
        {
            if (index.HasValue)
            {
                await JSRuntime.InvokeVoidAsync("localStorage.setItem", StorageKey, index.Value.ToString());
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("localStorage.removeItem", StorageKey);
            }
        }
        catch { }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender)
        {
            await InitializeViewportAsync();
            try
            {
                if (!string.IsNullOrEmpty(lastBuiltGroupNames))
                {
                    await JSRuntime.InvokeVoidAsync("console.log", $"NavigationTail (afterrender) built groups: {lastBuiltGroupNames}");
                }
            }
            catch { }
        }
    }

    private async Task InitializeViewportAsync()
    {
        await ResolveViewportKeyAsync();

        try
        {
            _dotNetRef ??= DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("navigationStorageSync.registerDotNet", _dotNetRef, StorageKey);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to register navigationStorageSync: {ex}");
            try { Logger?.LogDebug(ex, "navigationStorageSync registration failed"); } catch { }
        }

        await EnsureNavigationStateAsync();
    }

    private async Task ResolveViewportKeyAsync()
    {
        if (ActionInterop == null)
        {
            return;
        }

        try
        {
            var key = await ActionInterop.GetViewportBreakpointAsync();
            if (!string.IsNullOrWhiteSpace(key))
            {
                var normalized = key.ToLowerInvariant();
                if (!string.Equals(_viewportKey, normalized, StringComparison.Ordinal))
                {
                    _viewportKey = normalized;
                }
            }
        }
        catch (Exception ex)
        {
            try { Logger?.LogDebug(ex, "ResolveViewportKeyAsync failed"); } catch { }
        }
    }

    private async Task EnsureNavigationStateAsync()
    {
        try
        {
            var stored = await LoadActiveIndexFromStorageAsync();
            if (stored.HasValue && stored.Value >= 0 && stored.Value < visibleGroups.Count)
            {
                activeSubMenuIndex = stored.Value;
            }
        }
        catch (Exception ex)
        {
            try { Logger?.LogDebug(ex, "EnsureNavigationStateAsync failed"); } catch { }
        }

        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public Task OnExternalStorageChange(string? newValue)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(newValue))
            {
                // removed -> clear selection
                activeSubMenuIndex = null;
            }
            else if (int.TryParse(newValue, out var parsed))
            {
                // only update if different and still valid
                if (activeSubMenuIndex != parsed)
                {
                    if (visibleGroups != null && parsed >= 0 && parsed < visibleGroups.Count)
                    {
                        activeSubMenuIndex = parsed;
                    }
                    else
                    {
                        activeSubMenuIndex = null;
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"OnExternalStorageChange error: {ex}");
        }

        // ensure UI updates
        _ = InvokeAsync(StateHasChanged);
        return Task.CompletedTask;
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("navigationStorageSync.unregisterDotNet");
        }
        catch { }

        if (_dotNetRef != null)
        {
            _dotNetRef.Dispose();
            _dotNetRef = null;
        }
        try
        {
            NavigationManager.LocationChanged -= OnLocationChanged;
        }
        catch { }

        try
        {
            AuthenticationStateProvider.AuthenticationStateChanged -= OnAuthenticationStateChanged;
        }
        catch { }
    }

    private void OnAuthenticationStateChanged(Task<AuthenticationState> task)
    {
        // When auth changes, rebuild visible groups (run async but don't block the event)
        _ = InvokeAsync(async () =>
        {
            try
            {
                // ensure latest groups are built based on the new auth state
                await LoadGroupsAsync();
                await InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                try { Logger?.LogDebug(ex, "OnAuthenticationStateChanged handling failed"); } catch { }
            }
        });
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();
        // initialize selectedItem from current URI
        selectedItem = NormalizePath("/" + NavigationManager.ToBaseRelativePath(NavigationManager.Uri));
        NavigationManager.LocationChanged += OnLocationChanged;
    }

    private void OnLocationChanged(object? sender, Microsoft.AspNetCore.Components.Routing.LocationChangedEventArgs e)
    {
        selectedItem = NormalizePath("/" + NavigationManager.ToBaseRelativePath(e.Location));
        _ = InvokeAsync(StateHasChanged);
    }

    private record LinkSubgroup(string Title, List<NavLinkVm> Links);

    private static List<LinkSubgroup> GroupLinks(List<NavLinkVm> links)
    {
        var groups = new Dictionary<string, List<NavLinkVm>>(StringComparer.OrdinalIgnoreCase);
        foreach (var l in links)
        {
            // group by first URL segment
            var href = l.Href ?? "/";
            var parts = href.TrimStart('/').Split('/', StringSplitOptions.RemoveEmptyEntries);
            string seg;
            // If this looks like a db/database route, include the second segment to separate functions
            if (parts.Length >= 2 && (string.Equals(parts[0], "db", StringComparison.OrdinalIgnoreCase) || string.Equals(parts[0], "database", StringComparison.OrdinalIgnoreCase)))
            {
                seg = parts[0] + "/" + parts[1];
            }
            else
            {
                seg = parts.FirstOrDefault() ?? "/";
            }
            if (!groups.TryGetValue(seg, out var list))
            {
                list = new List<NavLinkVm>();
                groups[seg] = list;
            }
            list.Add(l);
        }

        // Convert to ordered list preserving original order within subgroup
        var result = groups.Select(g => new LinkSubgroup(g.Key, g.Value)).ToList();
        return result;
    }

    private void ToggleSubgroup(string subgroupKey)
    {
        if (string.IsNullOrEmpty(subgroupKey)) return;
        if (openSubgroups.Contains(subgroupKey)) openSubgroups.Remove(subgroupKey);
        else openSubgroups.Add(subgroupKey);
        _ = InvokeAsync(StateHasChanged);
    }

    private string ToFriendlyGroupTitle(string raw)
    {
        if (string.IsNullOrWhiteSpace(raw)) return string.Empty;
        var key = raw.Trim();
        // If group key contains '/', prefer the last segment for the display title
        if (key.Contains('/'))
        {
            var parts = key.Split('/', StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length > 0) key = parts.Last();
        }

        // Prefer localized resource if available
        try
        {
            var localized = Localizer?[key];
            if (!string.IsNullOrEmpty(localized)) return localized;
        }
        catch { }

        // Mapping table for common catalog keys
        var map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            ["products"] = "Products",
            ["orders"] = "Orders",
            ["subscriptions"] = "Subscriptions",
            ["customers"] = "Customers",
            ["discounts"] = "Discounts",
            ["licenses"] = "Licenses",
            ["store"] = "Store",
        };

        if (map.TryGetValue(key, out var mapped)) return mapped;

        // Fallback: title-case and replace dashes/underscores
        var cleaned = key.ToLowerInvariant().Replace('-', ' ').Replace('_', ' ');
        return System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(cleaned);
    }
}
