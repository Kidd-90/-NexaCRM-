.app-shell {
    min-height: 100vh;
    background: var(--surface-gradient, var(--surface-color));
}

html:not([data-theme="dark"]) .app-shell--desktop {
    background: #E5E7EB;
}

/* Background wrapper for nav-rail panel and content */
.app-shell__background {
    position: fixed;
    top: 0;
    left: 83px;
    min-width: calc(100% - 83px);
    margin-top: 5px;
    margin-bottom: 5px;

    height: 100%;
    right: 0;
    background: var(--surface-color, red);
    border: 1px solid var(--divider-color, #E5E7EB);
    border-radius: 1rem;
    z-index: 1;
    pointer-events: none;
}

.app-shell__background>* {
    pointer-events: auto;
}

.app-shell__surface {
    margin-left: var(--sidebar-width);
    /* further narrowed horizontal gutters to give the surface more width */
    padding-inline: clamp(0.75rem, 1.5vw, 1rem);
    /* Use a smaller top padding to visually align with the nav-rail panel */
    padding-top: var(--app-shell-surface-padding-top);
    padding-bottom: clamp(0.75rem, 1.5vw, 1rem);
    display: flex;
    flex-direction: column;
    /* Ensure the surface stays visible above main content even if they overlap */
    position: relative;
    z-index: 15;
    /* Make surface height equal to the fixed page header height + 5px so
          the surface and header sizes match closely. This uses the
          --app-shell-page-header-height variable which is set at runtime by
          layout.js (falls back to 57px if not available). */
    min-height: calc(var(--app-shell-page-header-height, 57px) + 5px);
    gap: var(--spacing-lg);
    transition: margin-left var(--transition-normal);
}

@media (min-width: 768px) {

    /* We offset the main document using body.padding-left on desktop, avoid
       an additional margin on the surface to prevent double-offset/overflow. */
    .app-shell__surface {
        margin-left: 0 !important;
    }
}

.app-shell__page-header {
    position: fixed;
    /* nudge the fixed header a little lower from the viewport top so it
         visually clears other chrome and doesn't overlap content when
         computed offsets are small. */
    /* anchor the page header to the very top of the viewport so content
          can reliably start immediately below it using the runtime offset
          variable. Use CSS variables for safe-area compatibility if needed. */
    top: 0;
    /* Place the fixed page header immediately to the right of the fixed
       navigation rail. Using the raw --sidebar-width keeps the header box
       aligned with the rail; we provide internal padding to maintain the
       visual gutter. */
    left: var(--sidebar-width, 0px);
    right: clamp(0.75rem, 1.5vw, 1rem);
    z-index: 30;
}

/* On mobile we don't render the fixed desktop rail; ensure the page header
   stretches edge-to-edge rather than being offset by the sidebar width. */
.app-shell--mobile .app-shell__page-header {
    left: 0 !important;
    right: 0.75rem;
    padding-inline-start: clamp(0.75rem, 1.5vw, 1rem);
}

.app-shell__content {
    /* Lift the content to start level with the fixed nav rail panel */
    margin-top: var(--nav-rail-vertical-offset-negative) !important;
    padding-top: 0;
    transition: margin-top 220ms ease, padding-top 220ms ease;
    /* 상하 스크롤 비활성화 */
    overflow-y: hidden;
    overflow-x: auto;
    /* Ensure content stays below nav-rail__panel */
    position: relative;
    z-index: 5;
    /* Match height with app-shell__background and nav-rail__panel exactly */
    height: calc(100vh - var(--nav-rail-vertical-offset));
    max-height: calc(100vh - var(--nav-rail-vertical-offset));
    box-sizing: border-box;
    /* Remove top padding to visually raise content; keep side/bottom padding */
    padding: 0 1rem 1rem 1rem;
}

/* Stronger, higher-specificity rules to prevent the main content from
   overlapping the fixed navigation rail. We use the sibling (~) selector so
   these rules only apply when a fixed .nav-rail exists earlier in the DOM.
   They also handle the collapsed rail and explicit mobile shell state. */
.nav-rail~.app-shell__content {
    /* Keep the same starting height as the fixed nav rail panel */
    margin-top: var(--nav-rail-vertical-offset-negative) !important;
    margin-right: 9px !important;
    margin-bottom: 0 !important;
    margin-left: 241px !important;
    width: calc(100% - 250px) !important;
    height: calc(100vh - var(--nav-rail-vertical-offset)) !important;
    max-width: calc(100% - 250px) !important;
    box-sizing: border-box;
}

/* When the rail is collapsed, use the narrower baseline width so the content
   stays close but doesn't overlap. */
.nav-rail.collapsed~.app-shell__content {
    margin-left: 56px !important;
    max-width: calc(100% - 56px) !important;
}

/* Mobile shell state should always allow full-width content (rail becomes overlay). */
.page.app-shell--mobile .app-shell__content,
.app-shell--mobile .app-shell__content {
    margin-left: 0 !important;
    max-width: 100% !important;
}

/* On mobile, when the header becomes visible/sticky, bump the offset so the
   content begins below the taller stacked header. */
@media (max-width: 767px) {
    :root {
        --app-shell-page-header-offset: var(--app-shell-page-header-offset-mobile);
    }
}

.app-shell__page-meta {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.app-shell__page-actions {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    padding: var(--spacing-xs) var(--spacing-sm);
    background: transparent;
    border: none;
    box-shadow: none;
}

.app-shell__page-icon {
    width: 3rem;
    height: 3rem;
    border-radius: 1rem;
    display: grid;
    place-items: center;
    background: var(--surface-muted);
    color: var(--primary-color);
    font-size: 1.35rem;
}

.app-shell__page-titles h1 {
    margin: 0;
    font-size: clamp(1.5rem, 2.4vw, 2rem);
    letter-spacing: -0.015em;
}

.app-shell__parent-link {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    border: none;
    background: transparent;
    color: var(--text-secondary);
    font-size: 0.85rem;
    margin-bottom: 0.25rem;
}

.app-shell__content {
    flex: 1;
    border-radius: 1rem;
    background: var(--background-color);
    border: 1px solid var(--divider-color);
    /* Keep top padding 0 while preserving responsive side/bottom gutters */
    padding: 0 clamp(0.75rem, 1.2vw, 1rem) clamp(0.75rem, 1.2vw, 1rem);
    /* main surface shadow: more pronounced on right and bottom for subtle 3D lift */
    box-shadow: 0 12px 20px rgba(15, 23, 42, 0.06), 6px 18px 40px rgba(15, 23, 42, 0.08);
}

/* Prevent first child margins from creating perceived top gaps */
.app-shell__content> :first-child {
    margin-top: 0 !important;
    padding-top: 0 !important;
}

/* Prevent the fixed navigation rail from overlapping the main content by
   offsetting the article using the shared --sidebar-width variable. Use
   max-width to avoid horizontal overflow. On mobile (app-shell--mobile) the
   sidebar is removed/overlaid so we clear the offsets. */
.app-shell__content {
    /* add a small visual gutter so the main surface doesn't touch the rail */
    margin-top: var(--nav-rail-vertical-offset-negative) !important;
    margin-left: 240px !important;
    width: calc(100% - 240px) !important;
    max-width: calc(100% - 240px) !important;
    box-sizing: border-box;
}

.app-shell--mobile .app-shell__content {
    margin-left: 0 !important;
    max-width: 100% !important;
}

.app-shell--mobile .app-shell__surface {
    margin-left: 0;
    padding: var(--spacing-md);
}

@media (max-width: 1024px) {
    .app-shell__surface {
        margin-left: clamp(0px, var(--sidebar-width) * 0.1, 2rem);
    }
}

/* Ensure the main surface is offset to the right of the fixed navigation rail
   on desktop/tablet breakpoints. Add a small gutter so content doesn't touch
   the rail. This rule is placed last to take precedence over earlier
   responsive adjustments. */
@media (min-width: 768px) {
    .app-shell__surface {
        /* even smaller gutter between sidebar and surface to use more horizontal space */
        margin-left: calc(var(--sidebar-width, 320px) + 6px) !important;
    }
}
