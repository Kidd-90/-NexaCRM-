@page "/statistics/dashboard"
@using System.Collections.Generic
@using System.Globalization
@using System.Linq
@using Microsoft.AspNetCore.Components.Web
@using NexaCRM.WebClient.Components.UI
@using NexaCRM.WebClient.Models.Statistics
@using NexaCRM.WebClient.Services.Interfaces
@inject IStatisticsService StatisticsService
@inject IJSRuntime JSRuntime

<ResponsivePage>
    <section class="dashboard-header">
        <div class="dashboard-header__copy">
            <p class="dashboard-header__eyebrow">Engagement overview</p>
            <h3>Statistics Dashboard</h3>
            <p class="dashboard-header__subtitle">
                Monitor how your community is growing and how resources are being adopted across the selected time window.
            </p>
        </div>
        <div class="dashboard-header__meta" aria-live="polite">
            <span class="dashboard-header__range">@GetRangeSummaryText()</span>
            <span class="dashboard-header__window">@GetRangeWindowText()</span>
        </div>
    </section>

    <section class="dashboard-toolbar" aria-label="Statistics dashboard controls">
        <div class="quick-ranges" role="group" aria-label="Quick date ranges">
            @foreach (var option in quickRangeOptions)
            {
                <button type="button"
                        class="quick-range-button @GetQuickRangeClass(option.Days)"
                        aria-pressed="@(activeQuickRangeDays == option.Days ? "true" : "false")"
                        disabled="@isLoading"
                        title="@option.Description"
                        @onclick="async () => await ApplyQuickRangeAsync(option.Days)">
                    <span class="quick-range-button__label">@option.Label</span>
                    <span class="quick-range-button__caption">@option.Description</span>
                </button>
            }
        </div>

        <div class="date-range" role="group" aria-label="Custom date range selection">
            <label class="date-field">
                <span>Start</span>
                <input type="date"
                       @bind="StartDate"
                       @bind:format="yyyy-MM-dd"
                       max="@EndDate.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture)" />
            </label>
            <label class="date-field">
                <span>End</span>
                <input type="date"
                       @bind="EndDate"
                       @bind:format="yyyy-MM-dd"
                       min="@StartDate.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture)"
                       max="@DateTime.Today.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture)" />
            </label>
            <button type="button" class="btn-refresh" @onclick="LoadStatistics" disabled="@isLoading">
                <span>@(isLoading ? "Refreshingâ€¦" : "Refresh")</span>
            </button>
        </div>
    </section>

    @if (isLoading)
    {
        <LoadingSpinner LoadingText="Loading statistics..." />
    }
    else if (stats is null ||
            (stats.Summary.TotalMembers == 0 && stats.Summary.TotalLogins == 0 && stats.Summary.TotalDownloads == 0))
    {
        <p>No statistics available for the selected date range.</p>
    }
    else
    {
        <section class="summary-tiles" aria-label="Key metrics summary">
            <article class="tile tile--members" style="--tile-accent: #6366f1; --tile-accent-rgb: 99, 102, 241;">
                <div class="tile__icon" aria-hidden="true">
                    <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
                        <circle cx="8" cy="9" r="3" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" />
                        <path d="M3 18c0-2.7 2.6-4 5-4s5 1.3 5 4" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" />
                        <circle cx="17" cy="8" r="2.5" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" />
                        <path d="M14 18c0-1.9 1.8-2.8 3-2.8 1.2 0 3 .9 3 2.8" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" />
                    </svg>
                </div>
                <div class="tile__content">
                    <span class="tile__label">Total Members</span>
                    <span class="tile__value">@FormatCount(stats.Summary.TotalMembers)</span>
                    <span class="tile__hint">As of @EndDate.ToString("MMM d, yyyy", CultureInfo.CurrentCulture)</span>
                </div>
            </article>
            <article class="tile tile--logins" style="--tile-accent: #2563eb; --tile-accent-rgb: 37, 99, 235;">
                <div class="tile__icon" aria-hidden="true">
                    <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
                        <polyline points="4 15 10 9 14 13 20 7" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" />
                        <path d="M4 11V7h4" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" />
                    </svg>
                </div>
                <div class="tile__content">
                    <span class="tile__label">Total Logins</span>
                    <span class="tile__value">@FormatCount(stats.Summary.TotalLogins)</span>
                    <div class="tile__meta">
                        <span class="tile__delta @GetTrendBadgeClass(stats.LoginTrend)">@GetTrendChangeText(stats.LoginTrend)</span>
                        <span class="tile__caption">vs previous day</span>
                    </div>
                    <span class="tile__hint">Sign-ins captured for the selected range</span>
                </div>
            </article>
            <article class="tile tile--downloads" style="--tile-accent: #0ea5e9; --tile-accent-rgb: 14, 165, 233;">
                <div class="tile__icon" aria-hidden="true">
                    <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
                        <path d="M12 4v9" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" />
                        <polyline points="8 10 12 14 16 10" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" />
                        <rect x="4" y="16" width="16" height="4" rx="1.2" fill="none" stroke="currentColor" stroke-width="1.6" />
                    </svg>
                </div>
                <div class="tile__content">
                    <span class="tile__label">Total Downloads</span>
                    <span class="tile__value">@FormatCount(stats.Summary.TotalDownloads)</span>
                    <div class="tile__meta">
                        <span class="tile__delta @GetTrendBadgeClass(stats.DownloadTrend)">@GetTrendChangeText(stats.DownloadTrend)</span>
                        <span class="tile__caption">vs previous day</span>
                    </div>
                    <span class="tile__hint">Resource downloads completed in the range</span>
                </div>
            </article>
        </section>

        <div class="trend-charts">
            <div class="chart-card" style="--chart-accent: #4c6ef5; --chart-accent-rgb: 76, 110, 245;">
                <div class="chart-card__header">
                    <div class="chart-card__titles">
                        <span class="chart-card__eyebrow">Activity</span>
                        <h4>Logins Trend</h4>
                        <span class="chart-card__subtitle">@GetTrendSubtitle(stats.LoginTrend)</span>
                    </div>
                    <div class="chart-card__value">
                        <span class="chart-card__number">@GetTrendLatestValue(stats.LoginTrend)</span>
                        <span class="chart-card__badge @GetTrendBadgeClass(stats.LoginTrend)">@GetTrendChangeText(stats.LoginTrend)</span>
                    </div>
                </div>
                @if (stats.LoginTrend.Any())
                {
                    var gradientId = GetGradientId("logins");
                    var lastPoint = GetTrendLastPoint(stats.LoginTrend);
                    <div class="chart-card__chart"
                         @ref="loginChartHostRef"
                         tabindex="0"
                         role="presentation"
                         @onpointerleave="HandleLoginPointerLeave"
                         @onfocus="HandleLoginFocus"
                         @onblur="HandleLoginBlur"
                         @onkeydown="HandleLoginKeyDown">
                        <svg viewBox="0 0 100 100"
                             preserveAspectRatio="none"
                             role="img"
                             aria-label="Logins trend"
                             @onpointermove="HandleLoginPointerMove">
                            <defs>
                                <linearGradient id="@gradientId" x1="0" y1="0" x2="0" y2="1">
                                    <stop offset="0%" stop-color="#4c6ef5" stop-opacity="0.38" />
                                    <stop offset="100%" stop-color="#4c6ef5" stop-opacity="0" />
                                </linearGradient>
                            </defs>
                            <g class="chart-grid">
                                @foreach (var y in GetHorizontalGridLines(4))
                                {
                                    <line x1="0" x2="100" y1="@FormatDouble(y)" y2="@FormatDouble(y)" vector-effect="non-scaling-stroke" />
                                }
                            </g>
                            <polygon class="chart-area" points="@GetTrendFillPoints(stats.LoginTrend)" fill="@($"url(#{gradientId})")" />
                            <polyline class="chart-line" points="@GetTrendLinePoints(stats.LoginTrend)" stroke="#4c6ef5" stroke-width="1.6" stroke-linecap="round" fill="none" vector-effect="non-scaling-stroke" />
                            @if (lastPoint is { } point)
                            {
                                <circle class="chart-dot" cx="@FormatDouble(point.X)" cy="@FormatDouble(point.Y)" r="1.8" fill="#4c6ef5" />
                            }
                            @if (allowInteractiveCharts && loginTooltip.IsVisible)
                            {
                                <line class="chart-hover-line" x1="@FormatDouble(loginTooltip.PositionX)" x2="@FormatDouble(loginTooltip.PositionX)" y1="0" y2="100" vector-effect="non-scaling-stroke" />
                                <circle class="chart-hover-dot" cx="@FormatDouble(loginTooltip.PositionX)" cy="@FormatDouble(loginTooltip.PositionY)" r="2.2" />
                            }
                        </svg>
                        @if (allowInteractiveCharts && loginTooltip.IsVisible)
                        {
                            <div class="chart-tooltip"
                                 role="status"
                                 style="--tooltip-x:@FormatDouble(loginTooltip.PositionX); --tooltip-y:@FormatDouble(loginTooltip.PositionY);">
                                <span class="chart-tooltip__title">@loginTooltip.Label</span>
                                <span class="chart-tooltip__value">@loginTooltip.Value.ToString("N0", CultureInfo.CurrentCulture)</span>
                                @if (!string.IsNullOrEmpty(loginTooltip.ChangeText))
                                {
                                    <span class="chart-tooltip__change">@loginTooltip.ChangeText</span>
                                }
                            </div>
                        }
                    </div>
                    <div class="chart-card__axis">
                        @foreach (var label in GetTrendAxisLabels(stats.LoginTrend))
                        {
                            <span>@label</span>
                        }
                    </div>
                    <div class="chart-card__insights" role="list">
                        <div class="chart-insight" role="listitem">
                            <span class="chart-insight__label">Peak day</span>
                            <span class="chart-insight__value">@GetTrendPeakInsight(stats.LoginTrend)</span>
                        </div>
                        <div class="chart-insight" role="listitem">
                            <span class="chart-insight__label">Daily average</span>
                            <span class="chart-insight__value">@GetTrendAverageInsight(stats.LoginTrend)</span>
                        </div>
                    </div>
                }
                else
                {
                    <div class="chart-card__empty">No data.</div>
                }
            </div>

            <div class="chart-card" style="--chart-accent: #0ea5e9; --chart-accent-rgb: 14, 165, 233;">
                <div class="chart-card__header">
                    <div class="chart-card__titles">
                        <span class="chart-card__eyebrow">Resources</span>
                        <h4>Downloads Trend</h4>
                        <span class="chart-card__subtitle">@GetTrendSubtitle(stats.DownloadTrend)</span>
                    </div>
                    <div class="chart-card__value">
                        <span class="chart-card__number">@GetTrendLatestValue(stats.DownloadTrend)</span>
                        <span class="chart-card__badge @GetTrendBadgeClass(stats.DownloadTrend)">@GetTrendChangeText(stats.DownloadTrend)</span>
                    </div>
                </div>
                @if (stats.DownloadTrend.Any())
                {
                    var gradientId = GetGradientId("downloads");
                    var lastPoint = GetTrendLastPoint(stats.DownloadTrend);
                    <div class="chart-card__chart"
                         @ref="downloadsChartHostRef"
                         tabindex="0"
                         role="presentation"
                         @onpointerleave="HandleDownloadsPointerLeave"
                         @onfocus="HandleDownloadsFocus"
                         @onblur="HandleDownloadsBlur"
                         @onkeydown="HandleDownloadsKeyDown">
                        <svg viewBox="0 0 100 100"
                             preserveAspectRatio="none"
                             role="img"
                             aria-label="Downloads trend"
                             @onpointermove="HandleDownloadsPointerMove">
                            <defs>
                                <linearGradient id="@gradientId" x1="0" y1="0" x2="0" y2="1">
                                    <stop offset="0%" stop-color="#0ea5e9" stop-opacity="0.38" />
                                    <stop offset="100%" stop-color="#0ea5e9" stop-opacity="0" />
                                </linearGradient>
                            </defs>
                            <g class="chart-grid">
                                @foreach (var y in GetHorizontalGridLines(4))
                                {
                                    <line x1="0" x2="100" y1="@FormatDouble(y)" y2="@FormatDouble(y)" vector-effect="non-scaling-stroke" />
                                }
                            </g>
                            <polygon class="chart-area" points="@GetTrendFillPoints(stats.DownloadTrend)" fill="@($"url(#{gradientId})")" />
                            <polyline class="chart-line" points="@GetTrendLinePoints(stats.DownloadTrend)" stroke="#0ea5e9" stroke-width="1.6" stroke-linecap="round" fill="none" vector-effect="non-scaling-stroke" />
                            @if (lastPoint is { } point)
                            {
                                <circle class="chart-dot" cx="@FormatDouble(point.X)" cy="@FormatDouble(point.Y)" r="1.8" fill="#0ea5e9" />
                            }
                            @if (allowInteractiveCharts && downloadsTooltip.IsVisible)
                            {
                                <line class="chart-hover-line" x1="@FormatDouble(downloadsTooltip.PositionX)" x2="@FormatDouble(downloadsTooltip.PositionX)" y1="0" y2="100" vector-effect="non-scaling-stroke" />
                                <circle class="chart-hover-dot" cx="@FormatDouble(downloadsTooltip.PositionX)" cy="@FormatDouble(downloadsTooltip.PositionY)" r="2.2" />
                            }
                        </svg>
                        @if (allowInteractiveCharts && downloadsTooltip.IsVisible)
                        {
                            <div class="chart-tooltip"
                                 role="status"
                                 style="--tooltip-x:@FormatDouble(downloadsTooltip.PositionX); --tooltip-y:@FormatDouble(downloadsTooltip.PositionY);">
                                <span class="chart-tooltip__title">@downloadsTooltip.Label</span>
                                <span class="chart-tooltip__value">@downloadsTooltip.Value.ToString("N0", CultureInfo.CurrentCulture)</span>
                                @if (!string.IsNullOrEmpty(downloadsTooltip.ChangeText))
                                {
                                    <span class="chart-tooltip__change">@downloadsTooltip.ChangeText</span>
                                }
                            </div>
                        }
                    </div>
                    <div class="chart-card__axis">
                        @foreach (var label in GetTrendAxisLabels(stats.DownloadTrend))
                        {
                            <span>@label</span>
                        }
                    </div>
                    <div class="chart-card__insights" role="list">
                        <div class="chart-insight" role="listitem">
                            <span class="chart-insight__label">Peak day</span>
                            <span class="chart-insight__value">@GetTrendPeakInsight(stats.DownloadTrend)</span>
                        </div>
                        <div class="chart-insight" role="listitem">
                            <span class="chart-insight__label">Daily average</span>
                            <span class="chart-insight__value">@GetTrendAverageInsight(stats.DownloadTrend)</span>
                        </div>
                    </div>
                }
                else
                {
                    <div class="chart-card__empty">No data.</div>
                }
            </div>
        </div>
    }
</ResponsivePage>

@code {
    private DateTime startDate = DateTime.Today.AddDays(-6);
    private DateTime endDate = DateTime.Today;
    private readonly QuickRangeOption[] quickRangeOptions = new[]
    {
        new QuickRangeOption("7D", "Last 7 days", 7),
        new QuickRangeOption("14D", "Last 14 days", 14),
        new QuickRangeOption("30D", "Last 30 days", 30),
    };
    private int? activeQuickRangeDays = 7;
    private StatisticsResult? stats;
    private bool isLoading = true;
    private ElementReference loginChartHostRef;
    private ElementReference downloadsChartHostRef;
    private TrendTooltipState loginTooltip = TrendTooltipState.Hidden();
    private TrendTooltipState downloadsTooltip = TrendTooltipState.Hidden();
    private int loginTooltipIndex = -1;
    private int downloadsTooltipIndex = -1;
    private double loginChartWidth;
    private double downloadsChartWidth;
    private bool allowInteractiveCharts;
    private bool chartsMeasured;

    private DateTime StartDate
    {
        get => startDate;
        set
        {
            if (startDate != value)
            {
                startDate = value.Date;
                activeQuickRangeDays = null;
            }
        }
    }

    private DateTime EndDate
    {
        get => endDate;
        set
        {
            if (endDate != value)
            {
                endDate = value.Date;
                activeQuickRangeDays = null;
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadStatistics();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                allowInteractiveCharts = await JSRuntime.InvokeAsync<bool>("nexaCharting.isFinePointer");
            }
            catch
            {
                allowInteractiveCharts = false;
            }
        }

        if (!allowInteractiveCharts || stats is null || chartsMeasured)
        {
            return;
        }

        try
        {
            loginChartWidth = await JSRuntime.InvokeAsync<double>("nexaCharting.getWidth", loginChartHostRef);
            downloadsChartWidth = await JSRuntime.InvokeAsync<double>("nexaCharting.getWidth", downloadsChartHostRef);
            chartsMeasured = loginChartWidth > 0 && downloadsChartWidth > 0;
        }
        catch
        {
            chartsMeasured = false;
        }
    }

    private async Task LoadStatistics()
    {
        isLoading = true;
        ResetTrendTooltips();
        chartsMeasured = false;
        loginChartWidth = 0;
        downloadsChartWidth = 0;

        if (startDate > endDate)
        {
            (startDate, endDate) = (endDate, startDate);
        }

        stats = await StatisticsService.GetStatisticsAsync(startDate, endDate);
        AlignActiveQuickRange();
        isLoading = false;
    }

    private async Task HandleLoginPointerMove(PointerEventArgs args)
    {
        if (stats is null)
        {
            return;
        }

        await HandleTrendPointerMove("login", args, stats.LoginTrend);
    }

    private async Task HandleDownloadsPointerMove(PointerEventArgs args)
    {
        if (stats is null)
        {
            return;
        }

        await HandleTrendPointerMove("downloads", args, stats.DownloadTrend);
    }

    private async Task HandleTrendPointerMove(string key, PointerEventArgs args, List<TrendPoint> trend)
    {
        if (!allowInteractiveCharts || string.Equals(args.PointerType, "touch", StringComparison.OrdinalIgnoreCase) || trend.Count == 0)
        {
            return;
        }

        await EnsureChartWidthAsync(key);
        var chartWidth = key == "login" ? loginChartWidth : downloadsChartWidth;
        if (chartWidth <= 0)
        {
            return;
        }

        var normalizedX = Math.Clamp(args.OffsetX / chartWidth * 100d, 0d, 100d);
        var normalized = NormalizeTrend(trend);
        if (normalized.Count == 0)
        {
            return;
        }

        var index = 0;
        var minDistance = double.MaxValue;
        for (var i = 0; i < normalized.Count; i++)
        {
            var distance = Math.Abs(normalized[i].X - normalizedX);
            if (distance < minDistance)
            {
                minDistance = distance;
                index = i;
            }
        }

        UpdateTrendTooltip(key, trend, normalized, index);
        await InvokeAsync(StateHasChanged);
    }

    private async Task EnsureChartWidthAsync(string key)
    {
        if (!allowInteractiveCharts)
        {
            return;
        }

        try
        {
            if (string.Equals(key, "login", StringComparison.Ordinal) && loginChartWidth <= 0)
            {
                loginChartWidth = await JSRuntime.InvokeAsync<double>("nexaCharting.getWidth", loginChartHostRef);
            }
            else if (string.Equals(key, "downloads", StringComparison.Ordinal) && downloadsChartWidth <= 0)
            {
                downloadsChartWidth = await JSRuntime.InvokeAsync<double>("nexaCharting.getWidth", downloadsChartHostRef);
            }
        }
        catch
        {
            if (string.Equals(key, "login", StringComparison.Ordinal))
            {
                loginChartWidth = 0;
            }
            else
            {
                downloadsChartWidth = 0;
            }
        }
    }

    private async Task HandleLoginPointerLeave()
    {
        if (!allowInteractiveCharts)
        {
            return;
        }

        HideTrendTooltip("login");
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleDownloadsPointerLeave()
    {
        if (!allowInteractiveCharts)
        {
            return;
        }

        HideTrendTooltip("downloads");
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleLoginFocus(FocusEventArgs _)
    {
        if (!allowInteractiveCharts || stats is null || stats.LoginTrend.Count == 0)
        {
            return;
        }

        var normalized = NormalizeTrend(stats.LoginTrend);
        UpdateTrendTooltip("login", stats.LoginTrend, normalized, stats.LoginTrend.Count - 1);
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleDownloadsFocus(FocusEventArgs _)
    {
        if (!allowInteractiveCharts || stats is null || stats.DownloadTrend.Count == 0)
        {
            return;
        }

        var normalized = NormalizeTrend(stats.DownloadTrend);
        UpdateTrendTooltip("downloads", stats.DownloadTrend, normalized, stats.DownloadTrend.Count - 1);
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleLoginBlur(FocusEventArgs _)
    {
        if (!allowInteractiveCharts)
        {
            return;
        }

        HideTrendTooltip("login");
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleDownloadsBlur(FocusEventArgs _)
    {
        if (!allowInteractiveCharts)
        {
            return;
        }

        HideTrendTooltip("downloads");
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleLoginKeyDown(KeyboardEventArgs args)
    {
        if (stats is null)
        {
            return;
        }

        await HandleTrendKeyDown("login", args, stats.LoginTrend);
    }

    private async Task HandleDownloadsKeyDown(KeyboardEventArgs args)
    {
        if (stats is null)
        {
            return;
        }

        await HandleTrendKeyDown("downloads", args, stats.DownloadTrend);
    }

    private async Task HandleTrendKeyDown(string key, KeyboardEventArgs args, List<TrendPoint> trend)
    {
        if (!allowInteractiveCharts || trend.Count == 0)
        {
            return;
        }

        var index = key == "login" ? loginTooltipIndex : downloadsTooltipIndex;
        if (index < 0)
        {
            index = trend.Count - 1;
        }

        switch (args.Key)
        {
            case "ArrowLeft":
            case "ArrowDown":
                index = Math.Max(0, index - 1);
                break;
            case "ArrowRight":
            case "ArrowUp":
                index = Math.Min(trend.Count - 1, index + 1);
                break;
            case "Home":
                index = 0;
                break;
            case "End":
                index = trend.Count - 1;
                break;
            default:
                return;
        }

        var normalized = NormalizeTrend(trend);
        UpdateTrendTooltip(key, trend, normalized, index);
        await InvokeAsync(StateHasChanged);
    }

    private void UpdateTrendTooltip(string key, List<TrendPoint> trend, List<(double X, double Y)> normalized, int index)
    {
        if (index < 0 || index >= trend.Count || normalized.Count <= index)
        {
            return;
        }

        var point = trend[index];
        var normalizedPoint = normalized[index];
        var delta = index > 0 ? point.Value - trend[index - 1].Value : 0;

        var tooltip = new TrendTooltipState
        {
            IsVisible = true,
            Label = point.Date.ToString("MMM d, yyyy", CultureInfo.CurrentCulture),
            Value = point.Value,
            ChangeText = index > 0 ? FormatTrendChange(delta) : null,
            PositionX = Math.Clamp(normalizedPoint.X, 4d, 96d),
            PositionY = Math.Clamp(normalizedPoint.Y, 6d, 94d)
        };

        if (string.Equals(key, "login", StringComparison.Ordinal))
        {
            loginTooltip = tooltip;
            loginTooltipIndex = index;
        }
        else
        {
            downloadsTooltip = tooltip;
            downloadsTooltipIndex = index;
        }
    }

    private void HideTrendTooltip(string key)
    {
        if (string.Equals(key, "login", StringComparison.Ordinal))
        {
            loginTooltip = TrendTooltipState.Hidden();
            loginTooltipIndex = -1;
        }
        else
        {
            downloadsTooltip = TrendTooltipState.Hidden();
            downloadsTooltipIndex = -1;
        }
    }

    private void ResetTrendTooltips()
    {
        loginTooltip = TrendTooltipState.Hidden();
        downloadsTooltip = TrendTooltipState.Hidden();
        loginTooltipIndex = -1;
        downloadsTooltipIndex = -1;
    }

    private async Task ApplyQuickRangeAsync(int days)
    {
        endDate = DateTime.Today;
        startDate = endDate.AddDays(-(days - 1));
        activeQuickRangeDays = days;
        await LoadStatistics();
    }

    private string GetQuickRangeClass(int days) => activeQuickRangeDays == days ? "active" : string.Empty;

    private string GetRangeSummaryText()
    {
        if (StartDate.Date == EndDate.Date)
        {
            return EndDate.ToString("MMM d, yyyy", CultureInfo.CurrentCulture);
        }

        return string.Format(CultureInfo.CurrentCulture, "{0:MMM d} â€“ {1:MMM d, yyyy}", StartDate, EndDate);
    }

    private string GetRangeWindowText()
    {
        var window = CalculateRangeDays(StartDate, EndDate);
        return FormatDayWindowText(window);
    }

    private static string FormatCount(int value) => value.ToString("N0", CultureInfo.CurrentCulture);

    private static string GetGradientId(string key) => $"trend-gradient-{key}";

    private static string FormatTrendChange(int delta)
        => delta.ToString("+0;-0;0", CultureInfo.CurrentCulture);

    private static string GetTrendSubtitle(List<TrendPoint> trend)
    {
        if (trend.Count == 0)
        {
            return "Awaiting data";
        }

        var first = trend.First().Date;
        var last = trend.Last().Date;

        if (first.Date == last.Date)
        {
            return first.ToString("MMM d, yyyy", CultureInfo.CurrentCulture);
        }

        return $"{first.ToString("MMM d", CultureInfo.CurrentCulture)} - {last.ToString("MMM d", CultureInfo.CurrentCulture)}";
    }

    private static string GetTrendLatestValue(List<TrendPoint> trend)
        => trend.Count == 0
            ? "0"
            : trend[^1].Value.ToString("N0", CultureInfo.CurrentCulture);

    private static string GetTrendChangeText(List<TrendPoint> trend)
    {
        if (trend.Count < 2)
        {
            return "0";
        }

        var delta = trend[^1].Value - trend[^2].Value;
        return delta.ToString("+#;-#;0", CultureInfo.CurrentCulture);
    }

    private static string GetTrendBadgeClass(List<TrendPoint> trend)
    {
        if (trend.Count < 2)
        {
            return "neutral";
        }

        var delta = trend[^1].Value - trend[^2].Value;
        if (delta > 0)
        {
            return "positive";
        }

        if (delta < 0)
        {
            return "negative";
        }

        return "neutral";
    }

    private static List<(double X, double Y)> NormalizeTrend(List<TrendPoint> trend)
    {
        var normalized = new List<(double X, double Y)>(trend.Count);
        if (trend.Count == 0)
        {
            return normalized;
        }

        var max = trend.Max(p => p.Value);
        var min = trend.Min(p => p.Value);
        var range = max - min;
        if (range == 0)
        {
            range = 1;
        }

        var denominator = Math.Max(trend.Count - 1, 1);

        for (var i = 0; i < trend.Count; i++)
        {
            var x = (double)i / denominator * 100d;
            var y = 100d - ((trend[i].Value - min) / (double)range * 100d);
            normalized.Add((x, y));
        }

        return normalized;
    }

    private static string GetTrendLinePoints(List<TrendPoint> trend)
    {
        var normalized = NormalizeTrend(trend);
        if (normalized.Count == 0)
        {
            return string.Empty;
        }

        var builder = new System.Text.StringBuilder(normalized.Count * 10);
        foreach (var point in normalized)
        {
            builder.AppendFormat(CultureInfo.InvariantCulture, "{0:F2},{1:F2} ", point.X, point.Y);
        }

        return builder.ToString().TrimEnd();
    }

    private static string GetTrendFillPoints(List<TrendPoint> trend)
    {
        var normalized = NormalizeTrend(trend);
        if (normalized.Count == 0)
        {
            return string.Empty;
        }

        var builder = new System.Text.StringBuilder(normalized.Count * 12);
        builder.AppendFormat(CultureInfo.InvariantCulture, "{0:F2},{1:F2} ", normalized[0].X, 100d);
        foreach (var point in normalized)
        {
            builder.AppendFormat(CultureInfo.InvariantCulture, "{0:F2},{1:F2} ", point.X, point.Y);
        }
        builder.AppendFormat(CultureInfo.InvariantCulture, "{0:F2},{1:F2}", normalized[^1].X, 100d);

        return builder.ToString();
    }

    private static (double X, double Y)? GetTrendLastPoint(List<TrendPoint> trend)
    {
        var normalized = NormalizeTrend(trend);
        if (normalized.Count == 0)
        {
            return null;
        }

        var point = normalized[^1];
        return (point.X, point.Y);
    }

    private static IEnumerable<double> GetHorizontalGridLines(int count)
    {
        if (count <= 0)
        {
            yield break;
        }

        for (var i = 1; i <= count; i++)
        {
            yield return (double)i / (count + 1) * 100d;
        }
    }

    private static string FormatDouble(double value) => value.ToString("F2", CultureInfo.InvariantCulture);

    private static IEnumerable<string> GetTrendAxisLabels(List<TrendPoint> trend)
    {
        if (trend.Count == 0)
        {
            yield break;
        }

        if (trend.Count == 1)
        {
            yield return trend[0].Date.ToString("MMM d", CultureInfo.CurrentCulture);
            yield break;
        }

        yield return trend.First().Date.ToString("MMM d", CultureInfo.CurrentCulture);

        if (trend.Count > 2)
        {
            yield return trend[trend.Count / 2].Date.ToString("MMM d", CultureInfo.CurrentCulture);
        }

        yield return trend.Last().Date.ToString("MMM d", CultureInfo.CurrentCulture);
    }

    private string GetTrendPeakInsight(List<TrendPoint> trend)
    {
        var peak = FindPeakPoint(trend);
        if (peak is null)
        {
            return "Awaiting data";
        }

        return string.Format(CultureInfo.CurrentCulture, "{0:N0} on {1:MMM d}", peak.Value, peak.Date);
    }

    private string GetTrendAverageInsight(List<TrendPoint> trend)
    {
        if (trend.Count == 0)
        {
            return "Awaiting data";
        }

        var average = trend.Average(point => point.Value);
        return string.Format(CultureInfo.CurrentCulture, "{0:N0} avg / day", average);
    }

    private static TrendPoint? FindPeakPoint(List<TrendPoint> trend)
    {
        TrendPoint? peak = null;
        foreach (var point in trend)
        {
            if (peak is null || point.Value > peak.Value)
            {
                peak = point;
            }
        }

        return peak;
    }

    private static int CalculateRangeDays(DateTime start, DateTime end)
    {
        var normalizedStart = start.Date;
        var normalizedEnd = end.Date;
        if (normalizedStart > normalizedEnd)
        {
            (normalizedStart, normalizedEnd) = (normalizedEnd, normalizedStart);
        }

        return (normalizedEnd - normalizedStart).Days + 1;
    }

    private static string FormatDayWindowText(int dayCount)
        => dayCount <= 1
            ? "Single day view"
            : string.Format(CultureInfo.CurrentCulture, "{0} day window", dayCount);

    private void AlignActiveQuickRange()
    {
        var window = CalculateRangeDays(startDate, endDate);
        foreach (var option in quickRangeOptions)
        {
            if (option.Days == window)
            {
                activeQuickRangeDays = option.Days;
                return;
            }
        }

        activeQuickRangeDays = null;
    }

    private sealed class TrendTooltipState
    {
        public bool IsVisible { get; set; }
        public string Label { get; set; } = string.Empty;
        public int Value { get; set; }
        public string? ChangeText { get; set; }
        public double PositionX { get; set; }
        public double PositionY { get; set; }

        public static TrendTooltipState Hidden() => new TrendTooltipState { IsVisible = false };
    }

    private sealed record QuickRangeOption(string Label, string Description, int Days);
}

